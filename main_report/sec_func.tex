\section{ФУНКЦИОНАЛЬНОЕ ПРОЕКТИРОВАНИЕ}
\label{sec:func}

В данном разделе модули описаны с точки зрения разработки функций, которые реализуются в
дипломном проекте. Функциональное проектирование нацелено на создание корректно и
эффективно работающего проекта. Представление необходимого функционала~-- основная задача
текущего раздела. После анализа требуемых для реализации программного продукта
функций, было решено разбить программу на следующие модули:

\begin{itemize}
    \item модуль \modulePerifery;
    \item модуль \moduleCalib;
    \item модуль \moduleCalibControl;
    \item модуль \moduleUart;
    \item модуль \moduleMoveDetect;
    \item модуль \moduleOrientationAzimuth;
    \item модуль \moduleFindTarget;
    \item модуль \moduleFlashMemory;
    \item модуль \moduleGraphics.
\end{itemize}

Каждый из модулей что был описан в предыдущем разделе, будет рассмотрен более детально
в данном разделе. Для реализации каждого модуля требуется реализация определенных функций
позволяющих соответствовать модулю заявленным требованиям.
Каждая функция называется определенным способом: сначала идет название модуля в котором располагается,
далее название разделяется символом <<\_>> и описывается то что делает данная функция.

Так как ПО работает без операционной системы на микроконтроллере, взаимодействие между модулями происходит
внутри одной программы и следовательно память используется общая, поэтому важно обеспечить изолированные
области памяти для каждого модуля, для корректной работы всей программы. Делается это через закрытый интерфейс,
а наружу выдается лишь адрес дескриптора с которым работает модуль. Также из-за отсутствия ОС необходимо,
реализовать потоки и переключение контекста в системе: делается это при помощи библиотеки <<ProtoThreads>>.
Данная библиотека предоставляет единицу программной обработки, обеспечиваемая средствами языка Cи, и позволяет
не задействовать механизмы потоков операционной системы.

Каждый модуль имеет собственные сообщения ошибок, которые позволяют модулям определять их состояние на выходе функции.
Ошибки начинаются с префикса, обозначающего названия модуля, и заканчивается описанием ошибки. Все модули включают в себя следующие
ошибки (<<*>> отмечено название модуля):

\begin{itemize}
    \item \lstinline{*_OK}~-- код успешного завершения функции;
    \item \lstinline{*_ERROR_UNKNOWN}~-- код в случае, если ошибка не установлена, например, 
    такой код возврата может быть, в случае неопределенного поведения как исполняемого модуля, так и внешнего;
    \item \lstinline{*_ERROR_INVALID_ARGUMENT}~-- код, если был подан неверный аргумент в функцию;
\end{itemize}

Остальные ошибки зависящие от реализации конкретного модуля определены в его открытом API, и содержат подробное описание ошибки.

Далее будет описана реализация каждого модуля, которая состоит из инициализации его дескриптора, функций обеспечивающих логику работы модуля
и потоков реализующих работу модуля.

Алгоритм получения и обработки данных представлен на схеме
данных \dataScheme. 
%% TODO: Add sequence diagram

\subsection{Описание работы библиотеки <<ProtoThreads>>}
%% Todo: узнать про причины использования РТ
При разработке программного обеспечения в связи с ограниченными ресурсами микроконтроллера было выбрана <<bare-metal>>
разработка~-- это означает, что программа исполняется на уровне процессора, обходя слой операционной системы.
В связи с отсутствием операционной системы работа приложения может быть очень долгой из-за синхронной обработки модулем событий:
во время работы модуля, различные ожидания могут очень сильно останавливать работу других модулей и, следовательно работу всего устройства в целом.
Из-за долгих ожиданий могут теряться важные сообщения из внешнего мира и периферии.

Переход на асинхронный режим позволяет решить проблему ожиданий во время работы модуля, вводит такое понятие как переключение контекста~-- переход программы
от одной задачи к другой, при этом данные в первой задаче сохраняются и ждут очереди на обработку, пока контекст снова не переключится на них. Также асинхронный
режим работы модуля позволяет делать асинхронные вызовы функций, их суть заключается в том, что в такие функции передается запрос на чтение/запись/обработку данных
и в параметры передается функция обратного вызова. Внутри асинхронных функций устанавливаются нужные флаги, и когда модуль, чей асинхронный вызов был использован,
обработает запрос, он вызовет переданную функцию обратного вызова с необходимыми данными. Модуль который обращался к асинхронной функции обработает данные переданные в обратный вызов
во время работы своего потока. Таким образом обеспечивается работа модулей только тогда, когда наступит их время выполнения, после одной итерации процесса происходит переключения контекста.

Для работы <<ProtoThreads>>, дескриптору потока, необходимо знать только адрес кода, где произошло переключение контекста. 
Примитивы для работы с потоками в качестве первого аргумента принимают дескриптор потока,
далее опционально в зависимости от того, что делает конкретный примитив.
В дипломном проектировании используются следующие примитивы библиотеки:

\begin{itemize}
    \item \lstinline{PT_INIT}~-- инициализирует поток;
    \item \lstinline{PT_BEGIN}~-- объявляет начало потока, данный примитив выполняет возобновление контекста(т.е. переход в то место процесса, где было совершено переключение контекста);
    \item \lstinline{PT_END}~-- объявляет завершение потока;
    \item \lstinline{PT_WAIT_UNTIL}~-- выполняет остановку потока, и ждет, когда условие не станет истинно, в ином случае переключает контекст.
    \item \lstinline{PT_WAIT_WHILE}~-- выполняет остановку потока, и ждет, когда условие истинно, в ином случае переключает контекст.
    \item \lstinline{PT_RESTART}~-- выполняет сброс потока и переключает контекст.
    \item \lstinline{PT_YIELD}~-- выполняет переключение контекста, поток продолжит работу начиная место вызова этого примитива.
    \item \lstinline{PT_SPAWN}~-- выполняет запуск дочернего потока и ожидает его завершения.
\end{itemize}

В ходе работы появилась необходимость, в расширении возможностей потоков, с целью улучшения читаемости кода,
поэтому на основе описанных выше примитивов были созданы новые функции управлением потоками:

\begin{itemize}
    \item \lstinline{PT_SLEEP_*}~-- переводит поток в ожидание на определенное время,
    вместо <<*>> может быть указано MS либо SEC, что означает, что указанное время передано в миллисекундах или секундах соответственно.
    После истечения времени поток возобновляет работу в месте где произошло переключение контекста;
    \item \lstinline{PT_WAIT_UNTIL_WITH_TIMEOUT_*}~-- ожидает выполнения пока условия с таймаутом пока оно не станет истинно
    по истечении которого выводится сообщение об истечении времени, вместо <<*>> может быть указано MS либо SEC,
    что означает, что указанное время передано в миллисекундах или секундах соответственно;
    \item \lstinline{PT_WAIT_WHILE_WITH_TIMEOUT_*}~-- ожидает выполнения пока условия с таймаутом пока оно истинно
    по истечении которого выводится сообщение об истечении времени, вместо <<*>> может быть указано MS либо SEC,
    что означает, что указанное время передано в миллисекундах или секундах соответственно;
    \item \lstinline{PT_WAIT_INFINITE}~-- переключает поток в зацикленный режим, необходим для того чтобы процесс был гарантированно остановлен и не мог начать работу заново.
    \item \lstinline{PT_PARENT_SANITY_CHECK_ALWAYS_N}~-- выполняет проверку истинности условия в родительском потоке,
    в случае ложного условия перезапустит поток и выведет сообщение об ошибке.
    \item \lstinline{PT_CHILD_SANITY_CHECK_ALWAYS_N}~-- выполняет проверку истинности условия в дочернем потоке,
    в случае ложного условия перезапустит поток и выведет сообщение об ошибке.
\end{itemize}

\nomenclaturex{SoC}{.}{.}

\subsection{Модуль \modulePerifery}
%TODO add link to documentation
Модуль \modulePerifery\ является одной из частей блока приема и обработки
датчиков. Модуль внутри содержит драйвера для двух датчиков: магнитометра, акселерометра и гироскопа (2-в-1).

\subsubsection{Драйвер магнитометра}

Библиотека с реализацией драйвера магнитометра использует функции, структуры и перечисления,
которые начинаются с префикса \lstinline{magnetoMMC5633NJL_}, и константы, перечисления, которые начинаются с префикса \lstinline{MAGNETOMMC5633NJL_}.

Для создания дескриптора модуля используется функция
\lstinline{magnetoMMC5633NJL_create}, данная функция не принимает никаких аргументов, внутри, данная функция, сначала проверяет
был ли создан уже дескриптор, если был то функция возвращает невалидный дескриптор обозначающий ошибку его создания, в ином случае
функция обнуляет данные в памяти дескриптора \lstinline{magnetoMMC5633NJL_handle_t} и возвращает его адрес. 

Чтобы запустить модуль необходимо его открыть при помощи функции
\lstinline{magnetoMMC5633NJL_open}. В функцию открытия модуля передаются параметры необходимые для работы модуля, первый из этих параметров
~-- это адрес дескриптора модуля, описанный в структуре \lstinline{memsLSM6DSO_handle_t}, следующий параметр это дескриптор драйвера шины IIC, необходимый для конфигурации датчика и чтения оттуда данных, и последние два параметра~--
это функция обратного вызова и аргумент передаваемый в эту функцию. Все параметры переданные в функцию открытия модуля сохраняются в дескрипторе магнетометра.
Помимо этого в функции происходит обнуление буфера требуемых для передачи и приема дынных по шине IIC, происходит инициализация флагов:

\begin{itemize}
    \item \lstinline{i2cThread.i2cReady}~-- устанавливается в \lstinline{true}, означает, что шина готова принимать и передавать данные;
    \item \lstinline{isOpened}~-- устанавливается в \lstinline{true}, означает, что модуль начал инициализацию.
    \item \lstinline{isOpenFinished}~-- устанавливается в \lstinline{false}, означает, что модуль не закончил процесс инициализации.
    \item \lstinline{isCloseFinished}~-- устанавливается в \lstinline{false}, означает, что модуль не закончил процесс остановки (закрытия).
\end{itemize}

Далее чтобы начать модулю работать необходимо проинициализировать потоки:

\begin{itemize}
    \item \lstinline{singleMeasurementPt}~-- дескриптор основного потока \lstinline{magnetoMMC5633NJL_singleMeasurement_thread} в котором модуль читает данные от датчика;
    \item \lstinline{readIdentifierPt}~-- дескриптор дочернего потока \lstinline{magnetoMMC5633NJL_readIdentifier} для чтения идентификатора датчика;
    \item \lstinline{selfTestPt}~--  дескриптор дочернего потока \lstinline{magnetoMMC5633NJL_selfTest} для операции самотестирования;
    \item \lstinline{readBurstBlockingPt}~--  дескриптор дочернего потока \lstinline{magnetoMMC5633NJL_readBurstBlocking} для чтения информации с шины IIC в буфер;
    \item \lstinline{writeBurstBlockingPt}~--  дескриптор дочернего потока \lstinline{magnetoMMC5633NJL_writeBurstBlocking} для записи информации в датчик;
    \item \lstinline{softwareResetPt}~--  дескриптор дочернего потока \lstinline{magnetoMMC5633NJL_softwareReset} для программного сброса датчика.
\end{itemize}

Для окончания инициализации модуля, нужно провести операцию самотестирования с целью определения корректности работы датчика. После данной операции
будет считаться, что модуль проинициализирован и готов к измерениям, флаг дескриптора магнетометра, \lstinline{isOpenFinished}, установится в \lstinline{true}.
За это отвечает поток открытия \lstinline{magnetoMMC5633NJL_openFinalize_thread}, вначале, поток ожидает когда модуль начнет инициализацию в вызове \lstinline{magnetoMMC5633NJL_open},
после установки флага \lstinline{isOpened}~-- устанавливается в \lstinline{true} поток запускает дочерний поток \lstinline{magnetoMMC5633NJL_readIdentifier} 
при помощи \lstinline{PT_SPAWN}, который вычитывает идентификатор из регистра и сверяет его с тем идентификатором, что определен в документации на датчик.

После завершения чтения идентификатора модуль проверяет статус чтения при помощи \lstinline{PT_PARENT_SANITY_CHECK_ALWAYS_N}. Далее
если идентификатор прочитан успешно происходит операция самотестирования. Но перед этим требуется совершить программный сброс датчика
при помощи запуска потока \lstinline{magnetoMMC5633NJL_softwareReset},
делается это для сброса управляющего регистра датчика. Если сброс прошел успешно, то модуль готов для операции самотестирования, 
которая происходит в потоке \lstinline{magnetoMMC5633NJL_selfTest}.
Данный поток сначала считывает данные записанные в регистре для самотестирования \lstinline{MAGNETOMMC5633NJL_ST_START_ADDR},
далее согласно документации 
нужно найти 80\% от этих данных и записать их в регистр \lstinline{MAGNETOMMC5633NJL_THR_ST_START_ADDR} после записи в управляющий 
регистр нужно установить флаги
\lstinline{MAGNET_CONTROL0_TAKE_MEAS_M_MASK | MAGNET_CONTROL0_AUTO_ST_EN_MASK}
и прочитать регистр \lstinline{MAGNETOMMC5633NJL_STATUS_REG} хранящий статус датчика.
Если
бит \lstinline{MAGNETOMMC5633NJL_SAT_SENSOR_MASK} установлен в ноль, то считается,
что датчик работает корректно, модуль закончил процесс инициализации и флаг \lstinline{isOpenFinished} устанавливается в \lstinline{true}.

Когда модуль проинициализирован и установлен флаг \lstinline{isOpenFinished} в \lstinline{true}, поток \lstinline{magnetoMMC5633NJL_singleMeasurement_thread},
считывающий данные с датчика, начинает свою работу. Перед чтением устанавливается флаг \lstinline{MAGNET_CONTROL0_TAKE_MEAS_M_MASK}, означающий провести измерениям,
и флаг \lstinline{MAGNET_CONTROL0_AUTO_SR_EN_MASK}, означающий, что после чтения данных, будут записаны новые. После установки флагов
из регистр статуса \lstinline{MAGNETOMMC5633NJL_STATUS_REG}, проверяется бит \lstinline{MAGNET_STATUS1_MEAS_M_DONE}, установка которого в 1 говорит о
готовности данных. Далее происходит вычитывание данных из регистров начиная с регистра \lstinline{MAGNETOMMC5633NJL_MEAS_START_ADDR} и масштабирование полученных данных
к реальным физическим величинам, в нашем случае это гауссы, и отправка этих данных далее в модуль, с которым модуль магнетометра связан обратным вызовом.
Данные об измерениях хранятся в структуре \lstinline{magnetoMMC5633NJL_measurements_t} и содержит измерения магнитного поля земли по трём осям.

\subsubsection{Драйвер акселерометра/гироскопа}
%TODO: Add link to documentation
Библиотека с реализацией драйвера магнитометра использует функции, структуры,
которые начинаются с префикса \lstinline{memsLSM6DSO_}, и константы, перечисления, которые начинаются с префикса \lstinline{MEMSLSM6DSO_}.
Особенность драйвера в том, что он состоит получает данные сразу от гироскопа и акселерометра, сделано так из-за
того, что датчик является устройством два-в-одном и содержит два сенсора, создавать два отдельных драйвера нецелесообразно:
\begin{itemize}
    \item количество кода будет больше, из-за двух функций открытия/закрытия и двух потоков, вместо всего по одному;
    \item драйвер содержит FIFO буфер, который удобнее читать из одного места, вместо двух, так как он помещает данные
    измеренные в один момент времени от двух датчиков;
\end{itemize}

\nomenclaturex{FIFO}{.}{.}

Создание дескриптора для дальнейшей работы драйвера начинается с функции \lstinline{memsLSM6DSO_create}, в
которой происходит очистка дескриптора, проверка, не было ли создан, данный дескриптор в процессе работы программы.
Функция возвращает адрес созданного дескриптора \lstinline{memsLSM6DSO_handle_t}.

Как и в случае с драйвером магнетометра, требуется открытие модуля и инициализация потоков, ответственных за
работу модуля. Функция \lstinline{memsLSM6DSO_open} принимает дескриптор драйвера шины IIC, функцию обратного вызова
и агрумент этой функции. В функции инициализируются дескрипторы следующих потоков:

\begin{itemize}
    \item \lstinline{singleMeasurementPt}~-- дескриптор основного потока \lstinline{memsLSM6DSO_singleMeasurement_thread} в котором модуль читает данные от датчика;
    \item \lstinline{readIdentifierPt}~-- дескриптор дочернего потока \lstinline{memsLSM6DSO_readIdentifier} для чтения идентификатора датчика;
    \item \lstinline{readBurstBlockingPt}~--  дескриптор дочернего потока \lstinline{memsLSM6DSO_readBurstBlocking} для чтения информации с шины IIC в буфер;
    \item \lstinline{writeBurstBytePt}~--  дескриптор дочернего потока \lstinline{memsLSM6DSO_readBurstBlocking} для чтения информации с шины IIC в буфер;
    \item \lstinline{writeBurstBlockingPt}~--  дескриптор дочернего потока \lstinline{memsLSM6DSO_writeBurstBlocking} для записи информации в датчик;
    \item \lstinline{softwareResetPt}~--  дескриптор дочернего потока \lstinline{memsLSM6DSO_softwareReset} для программного сброса датчика.
\end{itemize}

Для работы модуля нужно установить следующие флаги:

\begin{itemize}
    \item \lstinline{fifoHandle.modeFIFO}~-- устанавливается \lstinline{MEMSLSM6DSO_FIFO_MODE_DEFAULT | MEMSLSM6DSO_FIFO_TIMESTAMP_DECIMATION_1},
    означает, что FIFO останавливает прием данных при полном заполнении и устанавливает текущий период записи данных в FIFO;
    \item \lstinline{fifoHandle.bypassFIFO}~-- устанавливается в \lstinline{MEMSLSM6DSO_FIFO_BYPASS}, означает, что FIFO;
    \item \lstinline{i2cThread.i2cReady}~-- устанавливается в \lstinline{true}, означает, что шина готова принимать и передавать данные;
    \item \lstinline{isOpened}~-- устанавливается в \lstinline{true}, означает, что модуль начал инициализацию.
    \item \lstinline{isOpenFinished}~-- устанавливается в \lstinline{false}, означает, что модуль не закончил процесс инициализации.
    \item \lstinline{isCloseFinished}~-- устанавливается в \lstinline{false}, означает, что модуль не закончил процесс остановки (закрытия).
\end{itemize}

После модулю необходимо завершить инициализацию в потоке \lstinline{memsLSM6DSO_openFinalize_thread}, в котором на старте для проверки вычитывается
идентификатор датчика ~-- успешно считанный идентификатор говорит о корректной работе устройства. Далее происходит сброс вызовом потока
\lstinline{memsLSM6DSO_softwareReset} и последовательно записывается конфигурация устройства, в таблице \ref{table:func:memsConf} описано назначение
каждого регистра и параметра записываемого в него.

\begin{table}[ht]
    \caption{Конфигурационные параметры датчика}
    \label{table:func:memsConf}
    \begin{tabular}{| >{\raggedright}m{0.2\textwidth}
                    | >{\raggedright}m{0.36\textwidth}
                    | >{\raggedright\arraybackslash}m{0.380\textwidth}|}
        \hline
        \centering Регистр & \centering Параметр & \centering\arraybackslash Описание \\
  
        \hline
        \lstinline[]$CTRL9_XL$ & 
        \lstinline[]$I3C_DISABLE$ & 
        Отключение режима работы по шине I3C
        \\  
        \hline
        \lstinline[]$FIFO_CTRL1$ & 
        \lstinline[]$FIFO_WATERMARK$& 
        Определяет размер буфера равным 6 байт
        \\  
        \hline
        \lstinline[]$FIFO_CTRL2$ & 
        \lstinline[]$FIFO_STOP_ON_WTM$ & 
        Включает ограничение размера буфера до установленного
        \\  
        \hline
        \lstinline[]$FIFO_CTRL3$ & 
        \lstinline[]$FIFO_BDR$ & 
        Устанавливает частоту записи данных в буфер равной 12,5 Гц
        \\  
        \hline
        \lstinline[]$CTRL10_C$ & 
        \lstinline[]$TIMESTAMP_ENABLE$ & 
        Включение разницы времени между измерениями
        \\
        \hline
        \lstinline[]$CTRL1_XL$ & 
        \lstinline[]$XL_ODR_12_5Hz_4g$ & 
        Установка частоты измерений акселерометра равной 12,5 Гц, а также амплитуду измерений равной 4 g
        \\
        \hline
        \lstinline[]$CTRL2_G$ & 
        \lstinline[]$G_ODR_12_5Hz_250dps$ & 
        Установка частоты измерений гироскопа 12,5 Гц, а также амплитуду измерений равной 250 град./сек.
        \\
        \hline
    \end{tabular}
  \end{table}

После успешной конфигурации устройство считается готовым к работе, выставляется флаг \lstinline{isOpenFinished} в \lstinline{true}, и начинает
работать основной поток \lstinline{memsLSM6DSO_singleMeasurement_thread}. Чтение измерений начинается с записи в регистр \lstinline{MEMSLSM6DSO_FIFO_CTRL4}
параметров из дескриптора: \lstinline{fifo.modeFIFO} для начала записи новых данных.
Чтение из FIFO сначала выполняется чтением статуса, содержащем информацию о размере буфера. После вычитывается регистр меток
который содержит номер текущей метки и метку о том какие измерения лежат в буфере (акселерометра/гироскопа). 
Далее проверяется, что номер метки читаемых данных не совпадает с номером метки текущих данных,
и в соответствии с меткой читаются данные в структуру дескриптора \lstinline{memsLSM6DSO_measurements_t}, что содержит измерения акселерометра и гироскопа и время между измерениями.
После успешного чтения поток сначала масштабирует данные к физическим величинам, вычитывает
метку времени с ее корректировкой согласно документации на датчик, и очищает буфер при помощи параметра указанного в \lstinline{fifo->bypassFIFO}.
И в конце поток выполняет обратный вызов с данными лежащими в структуре \lstinline{memsLSM6DSO_measurements_t}, что содержит измерения акселерометра и гироскопа и время между измерениями.

\subsection{Модуль калибровки}
