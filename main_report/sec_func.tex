\section{ФУНКЦИОНАЛЬНОЕ ПРОЕКТИРОВАНИЕ}
\label{sec:func}

В данном разделе модули описаны с точки зрения разработки функций, которые реализуются в
дипломном проекте. Функциональное проектирование нацелено на создание корректно и
эффективно работающего проекта. Представление необходимого функционала~-- основная задача
текущего раздела. После анализа требуемых для реализации программного продукта
функций, было решено разбить программу на следующие модули:

\begin{itemize}
    \item модуль \modulePerifery;
    \item модуль \moduleCalib;
    \item модуль \moduleCalibControl;
    \item модуль \moduleUart;
    \item модуль \moduleMoveDetect;
    \item модуль \moduleOrientationAzimuth;
    \item модуль \moduleFindTarget;
    \item модуль \moduleFlashMemory;
    \item модуль \moduleGraphics.
\end{itemize}

Каждый из модулей что был описан в предыдущем разделе, будет рассмотрен более детально
в данном разделе. Для реализации каждого модуля требуется реализация определенных функций
позволяющих соответствовать модулю заявленным требованиям.
Каждая функция называется определенным способом: сначала идет название модуля в котором располагается,
далее название разделяется символом <<\_>> и описывается то что делает данная функция.

Так как ПО работает без операционной системы на микроконтроллере, взаимодействие между модулями происходит
внутри одной программы и следовательно память используется общая, поэтому важно обеспечить изолированные
области памяти для каждого модуля, для корректной работы всей программы. Делается это через закрытый интерфейс,
а наружу выдается лишь адрес дескриптора с которым работает модуль. Также из-за отсутствия ОС необходимо,
реализовать потоки и переключение контекста в системе: делается это при помощи библиотеки <<ProtoThreads>>.
Данная библиотека предоставляет единицу программной обработки, обеспечиваемая средствами языка Cи, и позволяет
не задействовать механизмы потоков операционной системы.

Каждый модуль имеет собственные сообщения ошибок, которые позволяют модулям определять их состояние на выходе функции.
Ошибки начинаются с префикса, обозначающего названия модуля, и заканчивается описанием ошибки. Все модули включают в себя следующие
ошибки (<<*>> отмечено название модуля):

\begin{itemize}
    \item \lstinline{*_OK}~-- код успешного завершения функции;
    \item \lstinline{*_ERROR_UNKNOWN}~-- код в случае, если ошибка не установлена, например, 
    такой код возврата может быть, в случае неопределенного поведения как исполняемого модуля, так и внешнего;
    \item \lstinline{*_ERROR_INVALID_ARGUMENT}~-- код, если был подан неверный аргумент в функцию;
\end{itemize}

Остальные ошибки зависящие от реализации конкретного модуля определены в его открытом API, и содержат подробное описание ошибки.

Далее будет описана реализация каждого модуля, которая состоит из инициализации его дескриптора, функций обеспечивающих логику работы модуля
и потоков реализующих работу модуля. Помимо функциональной части модулей/подмодулей в ходе описания будут упоминаться различные атрибуты структур,
которые имеют ключевое значение в работе модуля.

Алгоритм получения и обработки данных представлен на схеме
данных \dataScheme. 
%% TODO: Add sequence diagram

\subsection{Описание работы библиотеки <<ProtoThreads>>}
%% Todo: узнать про причины использования РТ
При разработке программного обеспечения в связи с ограниченными ресурсами микроконтроллера было выбрана <<bare-metal>>
разработка~-- это означает, что программа исполняется на уровне процессора, обходя слой операционной системы.
В связи с отсутствием операционной системы работа приложения может быть очень долгой из-за синхронной обработки модулем событий:
во время работы модуля, различные ожидания могут очень сильно останавливать работу других модулей и, следовательно работу всего устройства в целом.
Из-за долгих ожиданий могут теряться важные сообщения из внешнего мира и периферии.

Переход на асинхронный режим позволяет решить проблему ожиданий во время работы модуля, вводит такое понятие как переключение контекста~-- переход программы
от одной задачи к другой, при этом данные в первой задаче сохраняются и ждут очереди на обработку, пока контекст снова не переключится на них. Также асинхронный
режим работы модуля позволяет делать асинхронные вызовы функций, их суть заключается в том, что в такие функции передается запрос на чтение/запись/обработку данных
и в параметры передается функция обратного вызова. Внутри асинхронных функций устанавливаются нужные флаги, и когда модуль, чей асинхронный вызов был использован,
обработает запрос, он вызовет переданную функцию обратного вызова с необходимыми данными. Модуль который обращался к асинхронной функции обработает данные переданные в обратный вызов
во время работы своего потока. Таким образом обеспечивается работа модулей только тогда, когда наступит их время выполнения, после одной итерации процесса происходит переключения контекста.

Для работы <<ProtoThreads>>, дескриптору потока, необходимо знать только адрес кода, где произошло переключение контекста. 
Примитивы для работы с потоками в качестве первого аргумента принимают дескриптор потока,
далее опционально в зависимости от того, что делает конкретный примитив.
В дипломном проектировании используются следующие примитивы библиотеки:

\begin{itemize}
    \item \lstinline{PT_INIT}~-- инициализирует поток;
    \item \lstinline{PT_BEGIN}~-- объявляет начало потока, данный примитив выполняет возобновление контекста(т.е. переход в то место процесса, где было совершено переключение контекста);
    \item \lstinline{PT_END}~-- объявляет завершение потока;
    \item \lstinline{PT_WAIT_UNTIL}~-- выполняет остановку потока, и ждет, когда условие не станет истинно, в ином случае переключает контекст.
    \item \lstinline{PT_WAIT_WHILE}~-- выполняет остановку потока, и ждет, когда условие истинно, в ином случае переключает контекст.
    \item \lstinline{PT_RESTART}~-- выполняет сброс потока и переключает контекст.
    \item \lstinline{PT_YIELD}~-- выполняет переключение контекста, поток продолжит работу начиная место вызова этого примитива.
    \item \lstinline{PT_SPAWN}~-- выполняет запуск дочернего потока и ожидает его завершения.
\end{itemize}

В ходе работы появилась необходимость, в расширении возможностей потоков, с целью улучшения читаемости кода,
поэтому на основе описанных выше примитивов были созданы новые функции управлением потоками:

\begin{itemize}
    \item \lstinline{PT_SLEEP_*}~-- переводит поток в ожидание на определенное время,
    вместо <<*>> может быть указано MS либо SEC, что означает, что указанное время передано в миллисекундах или секундах соответственно.
    После истечения времени поток возобновляет работу в месте где произошло переключение контекста;
    \item \lstinline{PT_WAIT_UNTIL_WITH_TIMEOUT_*}~-- ожидает выполнения пока условия с таймаутом пока оно не станет истинно
    по истечении которого выводится сообщение об истечении времени, вместо <<*>> может быть указано MS либо SEC,
    что означает, что указанное время передано в миллисекундах или секундах соответственно;
    \item \lstinline{PT_WAIT_WHILE_WITH_TIMEOUT_*}~-- ожидает выполнения пока условия с таймаутом пока оно истинно
    по истечении которого выводится сообщение об истечении времени, вместо <<*>> может быть указано MS либо SEC,
    что означает, что указанное время передано в миллисекундах или секундах соответственно;
    \item \lstinline{PT_WAIT_INFINITE}~-- переключает поток в зацикленный режим, необходим для того чтобы процесс был гарантированно остановлен и не мог начать работу заново.
    \item \lstinline{PT_PARENT_SANITY_CHECK_ALWAYS_N}~-- выполняет проверку истинности условия в родительском потоке,
    в случае ложного условия перезапустит поток и выведет сообщение об ошибке.
    \item \lstinline{PT_CHILD_SANITY_CHECK_ALWAYS_N}~-- выполняет проверку истинности условия в дочернем потоке,
    в случае ложного условия перезапустит поток и выведет сообщение об ошибке.
\end{itemize}

\nomenclaturex{SoC}{.}{.}

\subsection{Модуль \modulePerifery}
%TODO add link to documentation
Модуль \modulePerifery\ является одной из частей блока приема и обработки
датчиков. Модуль внутри содержит драйвера для двух датчиков: магнитометра, акселерометра и гироскопа (2-в-1).

\subsubsection{Драйвер магнитометра}

Библиотека с реализацией драйвера магнитометра использует функции, структуры и перечисления,
которые начинаются с префикса \lstinline{magnetoMMC5633NJL_}, и константы, перечисления, которые начинаются с префикса \lstinline{MAGNETOMMC5633NJL_}.

Для создания дескриптора модуля используется функция
\lstinline{magnetoMMC5633NJL_create}, данная функция не принимает никаких аргументов, внутри, данная функция, сначала проверяет
был ли создан уже дескриптор, если был то функция возвращает невалидный дескриптор обозначающий ошибку его создания, в ином случае
функция обнуляет данные в памяти дескриптора \lstinline{magnetoMMC5633NJL_handle_t} и возвращает его адрес. 

Чтобы запустить модуль необходимо его открыть при помощи функции
\lstinline{magnetoMMC5633NJL_open}. В функцию открытия модуля передаются параметры необходимые для работы модуля, первый из этих параметров
~-- это адрес дескриптора модуля, описанный в структуре \lstinline{memsLSM6DSO_handle_t}, следующий параметр это дескриптор драйвера шины IIC, необходимый для конфигурации датчика и чтения оттуда данных, и последние два параметра~--
это функция обратного вызова и аргумент передаваемый в эту функцию. Все параметры переданные в функцию открытия модуля сохраняются в дескрипторе магнетометра.
Помимо этого в функции происходит обнуление буфера требуемых для передачи и приема дынных по шине IIC, происходит инициализация флагов:

\begin{itemize}
    \item \lstinline{i2cThread.i2cReady}~-- устанавливается в \lstinline{true}, означает, что шина готова принимать и передавать данные;
    \item \lstinline{isOpened}~-- устанавливается в \lstinline{true}, означает, что модуль начал инициализацию.
    \item \lstinline{isOpenFinished}~-- устанавливается в \lstinline{false}, означает, что модуль не закончил процесс инициализации.
    \item \lstinline{isCloseFinished}~-- устанавливается в \lstinline{false}, означает, что модуль не закончил процесс остановки (закрытия).
\end{itemize}

Далее чтобы начать модулю работать необходимо проинициализировать потоки:

\begin{itemize}
    \item \lstinline{singleMeasurementPt}~-- дескриптор основного потока \lstinline{magnetoMMC5633NJL_singleMeasurement_thread} в котором модуль читает данные от датчика;
    \item \lstinline{readIdentifierPt}~-- дескриптор дочернего потока \lstinline{magnetoMMC5633NJL_readIdentifier} для чтения идентификатора датчика;
    \item \lstinline{selfTestPt}~--  дескриптор дочернего потока \lstinline{magnetoMMC5633NJL_selfTest} для операции самотестирования;
    \item \lstinline{readBurstBlockingPt}~--  дескриптор дочернего потока \lstinline{magnetoMMC5633NJL_readBurstBlocking} для чтения информации с шины IIC в буфер;
    \item \lstinline{writeBurstBlockingPt}~--  дескриптор дочернего потока \lstinline{magnetoMMC5633NJL_writeBurstBlocking} для записи информации в датчик;
    \item \lstinline{softwareResetPt}~--  дескриптор дочернего потока \lstinline{magnetoMMC5633NJL_softwareReset} для программного сброса датчика.
\end{itemize}

Для окончания инициализации модуля, нужно провести операцию самотестирования с целью определения корректности работы датчика. После данной операции
будет считаться, что модуль проинициализирован и готов к измерениям, флаг дескриптора магнетометра, \lstinline{isOpenFinished}, установится в \lstinline{true}.
За это отвечает поток открытия \lstinline{magnetoMMC5633NJL_openFinalize_thread}, вначале, поток ожидает когда модуль начнет инициализацию в вызове \lstinline{magnetoMMC5633NJL_open},
после установки флага \lstinline{isOpened}~-- устанавливается в \lstinline{true} поток запускает дочерний поток \lstinline{magnetoMMC5633NJL_readIdentifier} 
при помощи \lstinline{PT_SPAWN}, который вычитывает идентификатор из регистра и сверяет его с тем идентификатором, что определен в документации на датчик.

После завершения чтения идентификатора модуль проверяет статус чтения при помощи \lstinline{PT_PARENT_SANITY_CHECK_ALWAYS_N}. Далее
если идентификатор прочитан успешно происходит операция самотестирования. Но перед этим требуется совершить программный сброс датчика
при помощи запуска потока \lstinline{magnetoMMC5633NJL_softwareReset},
делается это для сброса управляющего регистра датчика. Если сброс прошел успешно, то модуль готов для операции самотестирования, 
которая происходит в потоке \lstinline{magnetoMMC5633NJL_selfTest}.
Данный поток сначала считывает данные записанные в регистре для самотестирования \lstinline{MAGNETOMMC5633NJL_ST_START_ADDR},
далее согласно документации 
нужно найти 80\% от этих данных и записать их в регистр \lstinline{MAGNETOMMC5633NJL_THR_ST_START_ADDR} после записи в управляющий 
регистр нужно установить флаги
\lstinline{MAGNET_CONTROL0_TAKE_MEAS_M_MASK | MAGNET_CONTROL0_AUTO_ST_EN_MASK}
и прочитать регистр \lstinline{MAGNETOMMC5633NJL_STATUS_REG} хранящий статус датчика.
Если
бит \lstinline{MAGNETOMMC5633NJL_SAT_SENSOR_MASK} установлен в ноль, то считается,
что датчик работает корректно, модуль закончил процесс инициализации и флаг \lstinline{isOpenFinished} устанавливается в \lstinline{true}.

Когда модуль проинициализирован и установлен флаг \lstinline{isOpenFinished} в \lstinline{true}, поток \lstinline{magnetoMMC5633NJL_singleMeasurement_thread},
считывающий данные с датчика, начинает свою работу. Перед чтением устанавливается флаг \lstinline{MAGNET_CONTROL0_TAKE_MEAS_M_MASK}, означающий провести измерениям,
и флаг \lstinline{MAGNET_CONTROL0_AUTO_SR_EN_MASK}, означающий, что после чтения данных, будут записаны новые. После установки флагов
из регистр статуса \lstinline{MAGNETOMMC5633NJL_STATUS_REG}, проверяется бит \lstinline{MAGNET_STATUS1_MEAS_M_DONE}, установка которого в 1 говорит о
готовности данных. Далее происходит вычитывание данных из регистров начиная с регистра \lstinline{MAGNETOMMC5633NJL_MEAS_START_ADDR} и масштабирование полученных данных
к реальным физическим величинам, в нашем случае это гауссы, и отправка этих данных далее в модуль, с которым модуль магнетометра связан обратным вызовом.
Данные об измерениях хранятся в структуре \lstinline{magnetoMMC5633NJL_measurements_t} и содержит измерения магнитного поля земли по трём осям.

\subsubsection{Драйвер акселерометра/гироскопа}
%TODO: Add link to documentation
Библиотека с реализацией драйвера магнитометра использует функции, структуры,
которые начинаются с префикса \lstinline{memsLSM6DSO_}, и константы, перечисления, которые начинаются с префикса \lstinline{MEMSLSM6DSO_}.
Особенность драйвера в том, что он состоит получает данные сразу от гироскопа и акселерометра, сделано так из-за
того, что датчик является устройством два-в-одном и содержит два сенсора, создавать два отдельных драйвера нецелесообразно:
\begin{itemize}
    \item количество кода будет больше, из-за двух функций открытия/закрытия и двух потоков, вместо всего по одному;
    \item драйвер содержит FIFO буфер, который удобнее читать из одного места, вместо двух, так как он помещает данные
    измеренные в один момент времени от двух датчиков;
\end{itemize}

\nomenclaturex{FIFO}{.}{.}

Создание дескриптора для дальнейшей работы драйвера начинается с функции \lstinline{memsLSM6DSO_create}, в
которой происходит очистка дескриптора, проверка, не было ли создан, данный дескриптор в процессе работы программы.
Функция возвращает адрес созданного дескриптора \lstinline{memsLSM6DSO_handle_t}.

Как и в случае с драйвером магнетометра, требуется открытие модуля и инициализация потоков, ответственных за
работу модуля. Функция \lstinline{memsLSM6DSO_open} принимает дескриптор драйвера шины IIC, функцию обратного вызова
и агрумент этой функции. В функции инициализируются дескрипторы следующих потоков:

\begin{itemize}
    \item \lstinline{singleMeasurementPt}~-- дескриптор основного потока \lstinline{memsLSM6DSO_singleMeasurement_thread} в котором модуль читает данные от датчика;
    \item \lstinline{readIdentifierPt}~-- дескриптор дочернего потока \lstinline{memsLSM6DSO_readIdentifier} для чтения идентификатора датчика;
    \item \lstinline{readBurstBlockingPt}~--  дескриптор дочернего потока \lstinline{memsLSM6DSO_readBurstBlocking} для чтения информации с шины IIC в буфер;
    \item \lstinline{writeBurstBytePt}~--  дескриптор дочернего потока \lstinline{memsLSM6DSO_readBurstBlocking} для чтения информации с шины IIC в буфер;
    \item \lstinline{writeBurstBlockingPt}~--  дескриптор дочернего потока \lstinline{memsLSM6DSO_writeBurstBlocking} для записи информации в датчик;
    \item \lstinline{softwareResetPt}~--  дескриптор дочернего потока \lstinline{memsLSM6DSO_softwareReset} для программного сброса датчика.
\end{itemize}

Для работы модуля нужно установить следующие флаги:

\begin{itemize}
    \item \lstinline{fifoHandle.modeFIFO}~-- устанавливается \lstinline{MEMSLSM6DSO_FIFO_MODE_DEFAULT | MEMSLSM6DSO_FIFO_TIMESTAMP_DECIMATION_1},
    означает, что FIFO останавливает прием данных при полном заполнении и устанавливает текущий период записи данных в FIFO;
    \item \lstinline{fifoHandle.bypassFIFO}~-- устанавливается в \lstinline{MEMSLSM6DSO_FIFO_BYPASS}, означает, что FIFO;
    \item \lstinline{i2cThread.i2cReady}~-- устанавливается в \lstinline{true}, означает, что шина готова принимать и передавать данные;
    \item \lstinline{isOpened}~-- устанавливается в \lstinline{true}, означает, что модуль начал инициализацию.
    \item \lstinline{isOpenFinished}~-- устанавливается в \lstinline{false}, означает, что модуль не закончил процесс инициализации.
    \item \lstinline{isCloseFinished}~-- устанавливается в \lstinline{false}, означает, что модуль не закончил процесс остановки (закрытия).
\end{itemize}

После модулю необходимо завершить инициализацию в потоке \lstinline{memsLSM6DSO_openFinalize_thread}, в котором на старте для проверки вычитывается
идентификатор датчика ~-- успешно считанный идентификатор говорит о корректной работе устройства. Далее происходит сброс вызовом потока
\lstinline{memsLSM6DSO_softwareReset} и последовательно записывается конфигурация устройства, в таблице \ref{table:func:memsConf} описано назначение
каждого регистра и параметра записываемого в него.

\begin{table}[ht]
    \caption{Конфигурационные параметры датчика}
    \label{table:func:memsConf}
    \begin{tabular}{| >{\raggedright}m{0.2\textwidth}
                    | >{\raggedright}m{0.36\textwidth}
                    | >{\raggedright\arraybackslash}m{0.380\textwidth}|}
        \hline
        \centering Регистр & \centering Параметр & \centering\arraybackslash Описание \\
  
        \hline
        \lstinline[]$CTRL9_XL$ & 
        \lstinline[]$I3C_DISABLE$ & 
        Отключение режима работы по шине I3C
        \\  
        \hline
        \lstinline[]$FIFO_CTRL1$ & 
        \lstinline[]$FIFO_WATERMARK$& 
        Определяет размер буфера равным 6 байт
        \\  
        \hline
        \lstinline[]$FIFO_CTRL2$ & 
        \lstinline[]$FIFO_STOP_ON_WTM$ & 
        Включает ограничение размера буфера до установленного
        \\  
        \hline
        \lstinline[]$FIFO_CTRL3$ & 
        \lstinline[]$FIFO_BDR$ & 
        Устанавливает частоту записи данных в буфер равной 12,5 Гц
        \\  
        \hline
        \lstinline[]$CTRL10_C$ & 
        \lstinline[]$TIMESTAMP_ENABLE$ & 
        Включение разницы времени между измерениями
        \\
        \hline
        \lstinline[]$CTRL1_XL$ & 
        \lstinline[]$XL_ODR_12_5Hz_4g$ & 
        Установка частоты измерений акселерометра равной 12,5 Гц, а также амплитуду измерений равной 4 g
        \\
        \hline
        \lstinline[]$CTRL2_G$ & 
        \lstinline[]$G_ODR_12_5Hz_250dps$ & 
        Установка частоты измерений гироскопа 12,5 Гц, а также амплитуду измерений равной 250 град./сек.
        \\
        \hline
    \end{tabular}
  \end{table}

После успешной конфигурации устройство считается готовым к работе, выставляется флаг \lstinline{isOpenFinished} в \lstinline{true}, и начинает
работать основной поток \lstinline{memsLSM6DSO_singleMeasurement_thread}. Чтение измерений начинается с записи в регистр \lstinline{MEMSLSM6DSO_FIFO_CTRL4}
параметров из дескриптора: \lstinline{fifo.modeFIFO} для начала записи новых данных.
Чтение из FIFO сначала выполняется чтением статуса, содержащем информацию о размере буфера. После вычитывается регистр меток
который содержит номер текущей метки и метку о том какие измерения лежат в буфере (акселерометра/гироскопа). 
Далее проверяется, что номер метки читаемых данных не совпадает с номером метки текущих данных,
и в соответствии с меткой читаются данные в структуру дескриптора \lstinline{memsLSM6DSO_measurements_t}, что содержит измерения акселерометра и гироскопа и время между измерениями.
После успешного чтения поток сначала масштабирует данные к физическим величинам, вычитывает
метку времени с ее корректировкой согласно документации на датчик, и очищает буфер при помощи параметра указанного в \lstinline{fifo->bypassFIFO}.
И в конце поток выполняет обратный вызов с данными лежащими в структуре \lstinline{memsLSM6DSO_measurements_t}, что содержит измерения акселерометра и гироскопа и время между измерениями.

\subsection{Модуль калибровки}

Ключевой модуль в проекте -- это модуль калибровки, он отвечает за преобразование искаженных различными факторами данных, в вид близкий к действительности. 
Данный модуль состоит из подмодулей ориентированных на каждый датчик и реализует в себе алгоритмы калибровки описанные в разделе \ref{sec:domain}.
Ниже будет рассмотрено более детальнее функциональная реализация каждого из модуля.

\subsubsection{Модуль калибровки магнетометра}

За создание дескриптора модуля отвечает функция \lstinline{businessLayer_calibrationMagnetometerCreate}, внутри происходит обнуление дескриптора,
инициализация потоков и возврат адреса памяти на которую указывает структура. Далее происходит открытие модуля при помощи функции 
\lstinline{businessLayer_calibrationMagnetometerOpen}. Функция принимает собственно дескриптор \lstinline{businessLayer_calibrationMagnetometer_t},
дескриптор флэш-памяти, сектор памяти куда будут записаны калибровочные параметры, а также функция обратного вызова и ее аргумент, 
которая связывает модули и позволяет асинхронно передавать данные дальше. Функция собственно сохраняет в дескриптор функцию обратного вызова с ее агрументом,
а также сохраняет дескритор флэш-памяти вместе с сектором для дальнейшей работы с модулем \moduleFlashMemory. 

Дл чтения параметров из флэш-памяти определены следующие состояния определенные в \lstinline{calibration_flashRequestToReadParameters_t}:

\begin{enumerate_num}
    \item \lstinline{CALIBRATION_REQUEST_FOR_PARAMETERS} -- Запрос к флэш памяти на чтение данных.
    \item \lstinline{CALIBRATION_PARAMETERS_WAS_READ_SUCCESS} -- Чтение прошло успешно.
    \item \lstinline{CALIBRATION_PARAMETERS_WAS_READ_FAIL} -- Чтение завершилось ошибкой (из-за ошибки флэш памяти либо неверного кода crc32).
\end{enumerate_num}

Работа основного потока модуля определяется состояниями конечного автомата, которые определены в \lstinline{calibration_internalCommands_t} и перечисленны ниже:

\begin{enumerate_num}
    \item \lstinline{CALIBRATION_INTERNAL_COMMANDS_APPLY_CALIBRATION} -- Состояние, когда модуль принимает данные от магнетометра и калибрует их своими параметрами.
    \item \lstinline{CALIBRATION_INTERNAL_COMMANDS_RECALIBRATE} -- Состояние, когда магнитометр начинает калиброваться.
    \item \lstinline{CALIBRATION_INTERNAL_COMMANDS_RESET_TO_DEFAULTS} -- Состояние, когда модуль не смог вычитать параметры из флэш памяти, и читает стандартные.
    \item \lstinline{CALIBRATION_INTERNAL_COMMANDS_RECALIBRATE_CANCEL} -- Пришла команда на отмену калибровки модуля.
\end{enumerate_num}

Так как модуль получает асинхронно данные от модулей \modulePerifery~и \moduleFlashMemory , то в себе модуль имеет реализации функций обратного вызова для соответствующих модулей.
Реализация обратного вызова для \modulePerifery~ориентирована на получение данных от драйвера магнетометра и обращается к структуре \lstinline{calibration_magnetoCb_t},
в которой перечисленны данные от магнетометра в структуре \lstinline{businessLayer_calibrationMagnetometerInputMeasurements_t}, флаг того что данные были вычитаны \lstinline{magnetoWasRead}.
и код ошибки магнетометра \lstinline{error}. Данная структура является атрибутом дескриптора. Функция обратного вызова \lstinline{businessLayer_calibrationMagnetometerCallback} 
со стороны модуля калибровки магнетометра ожидает получение своего дескриптора, и кода ошибки. В функции устанавливаются флаг и данные от магнетометра.

Для связи с модулем \moduleFlashMemory~ используется обратный вызов \lstinline{calibration_flashCb}, данный обратный вызов ожидает получить дескриптор модуля калибровки магнетометра, код ошибки,
и количество прочитанных байт. Для хранения информации от обратного вызова модуль содержит структуру с данными, которые получает функция, а также устанавливает флаг \lstinline{flashIsReady}.

Главный поток работает по состояниям из \lstinline{calibration_flashRequestToReadParameters_t} и \lstinline{calibration_internalCommands_t}. И зависимости от состояний
поток вычитывает дынные из флэш памяти используя дочерний поток \lstinline{calibration_readParametersFromFlash}, который вычитывает данные и проверяет их корректность,
либо ожидает данные от магнитометра и применяет калибровочные параметры и вызывает функцию обратного вызова другого модуля, где в качестве аргумента передает откалиброванные измерения,
либо обрабатывает команду на калибровку, генерируя дочерний поток \lstinline{calibration_recalibrateCommandRoutine}, либо останавливает поток по команде, либо сбрасывает параметры инициализируя модуль
стандартными определенными параметрами.

Состояние \lstinline{CALIBRATION_REQUEST_FOR_PARAMETERS} является для модуля начальным, модуль может перейти в состояние \lstinline{CALIBRATION_PARAMETERS_WAS_READ_SUCCESS} и в процессе работы это состояние
будет для модуля конечным по части работы с модулем \moduleFlashMemory, либо в состояние \lstinline{CALIBRATION_PARAMETERS_WAS_READ_FAIL},
в котором модуль перейдет в состояние \lstinline{CALIBRATION_INTERNAL_COMMANDS_RESET_TO_DEFAULTS}, и вычитает стандартные
параметры и перейдет в состояние модуля калибровки данных от модуля калибровки магнитометра: \lstinline{CALIBRATION_INTERNAL_COMMANDS_APPLY_CALIBRATION}.
Если поступит команда на калибровку, то модуль переключится в состояние \lstinline{CALIBRATION_INTERNAL_COMMANDS_RECALIBRATE}, после которого модуль в любом случае переключится в состояние
\lstinline{CALIBRATION_INTERNAL_COMMANDS_APPLY_CALIBRATION}.

\subsubsection{Модуль калибровки акселерометра}

Модуль реализует математический способ калибровки описанный в \ref{sec:domain}, а также реализует механизм организации последовательности считывания данных и калибровку
текущих значений. 

Инициализация и открытие модуля калибровки акселерометра аналогична тому, как это делается в модуле калибровки магнитометра. Меняется только дескриптор описанный в данном модуле.
Связан модуль с другими модулями также как и в предыдущем случае, только сейчас на вход от модуля \modulePerifery ожидаются данные акселерометра.

Для работы модуля также необходимы состояния, которые используются в потоке и определены в \lstinline{calibrationAccelerometer_internalCommands_t}:

\begin{enumerate_num}
    \item \lstinline{CALIBRATION_ACCELEROMETER_COMMANDS_APPLY_CALIBRATION} -- Стандартное состояние калибровки входных данных.
    \item \lstinline{CALIBRATION_ACCELEROMETER_COMMANDS_RECALIBRATE} -- Состояние в котором прибор начинает операцию калибровки.
    \item \lstinline{CALIBRATION_ACCELEROMETER_COMMANDS_WAIT_NEW_POS} -- Ожидание установки нового определенного положения.
    \item \lstinline{CALIBRATION_ACCELEROMETER_COMMANDS_SET_POS} -- Сбор данных на установленной позиции.
    \item \lstinline{CALIBRATION_ACCELEROMETER_COMMANDS_RESET_TO_DEFAULTS} -- Сброс калибровочных параметров.
    \item \lstinline{CALIBRATION_ACCELEROMETER_COMMANDS_RECALIBRATE_CANCEL} -- Отмена калибровки прибора.
\end{enumerate_num}

В случае калибровки, необходимо определять положение прибора, в документации к использованию прибора приведена последовательность положений прибора,
в программной части идет такая же последовательность и описана в \lstinline{businessLayer_calibrationAccelerometerStates_t}:

\begin{enumerate_num}
    \item \lstinline{CALIBRATION_ACCELEROMETER_POSITION_Z_UP} -- Описывает положение осью Z вверх.
    \item \lstinline{CALIBRATION_ACCELEROMETER_POSITION_Z_DOWN} -- Описывает положение осью Z вверх.
    \item \lstinline{CALIBRATION_ACCELEROMETER_POSITION_Y_UP} -- Описывает положение осью Y вверх.
    \item \lstinline{CALIBRATION_ACCELEROMETER_POSITION_Y_DOWN} -- Описывает положение осью Y вверх.
    \item \lstinline{CALIBRATION_ACCELEROMETER_POSITION_X_UP} -- Описывает положение осью X вверх.
    \item \lstinline{CALIBRATION_ACCELEROMETER_POSITION_X_DOWN} -- Описывает положение осью X вверх.
    \item \lstinline{CALIBRATION_ACCELEROMETER_POSITION_FINISH} -- Определяет, что все данные собраны и устройство подсчитывает параметры.
    \item \lstinline{CALIBRATION_ACCELEROMETER_CALIBRATION_FINISHED} -- Определяет, что параметры были сохранены и записаны в флэш память.
\end{enumerate_num}

Состояния для взаимодействия с флэш памятью определены такие же как и в модуле калибровки магнетометра. 

Хоть и многое повторяется в данном модуле как и в модуле калибровки магнетометра, однако следует выделить,
то что модуль требователен к взаимодействию с пользователем и проверкой корректности
установки нового положения. Данный модуль не отвечает за это, в его случае требуется только знать о том, что состояние было установлено. Ответственность
за правильную последовательность отводится модулю \moduleCalibControl . Это было сделано для удобного использования управлением калибровкой устройства по
UART через один управляющий модуль. Управление за входящие сообщения об установке новой позиции принимает \lstinline{businessLayer_calibrationAccelerometerPositionWasSetCb},
он отслеживает три состояния в котором находится калибровка:

\begin{itemize}
    \item \lstinline{CALIBRATION_ACCELEROMETER_COMMANDS_RECALIBRATE} -- в данном состоянии модуль начинает калибровку, то есть предполагается, модуль находится в начальном положении;
    \item \lstinline{CALIBRATION_ACCELEROMETER_COMMANDS_WAIT_NEW_POS} -- в данном случае модуль устанавливает новую позицию;
    \item \lstinline{CALIBRATION_ACCELEROMETER_COMMANDS_SET_POS} -- в данном случае прерывается текущий сбор данных и происходит переключение в следующую позицию.
\end{itemize}


Каждое изменение состояния отслеживает основной поток, первое, что делает поток в начале работы -- читает параметры из флэш памяти и после успешного прочтения переходит в состояние
\lstinline{CALIBRATION_ACCELEROMETER_COMMANDS_APPLY_CALIBRATION}, если же параметры были вычитаны неверные, то поток переходит в состояние
\lstinline{CALIBRATION_ACCELEROMETER_COMMANDS_RESET_TO_DEFAULTS}, сбрасывает значения и записывает их обратно во флэш память, после переходит обратно в состояние
\lstinline{CALIBRATION_ACCELEROMETER_COMMANDS_APPLY_CALIBRATION}. По приходу команды \lstinline{CALIBRATION_ACCELEROMETER_COMMANDS_RECALIBRATE}, поток только
собирает данные.
После получения измерений всех позиций модуль переходит в состояние \lstinline{CALIBRATION_ACCELEROMETER_POSITION_FINISH} и поток начинает рассчитывать калибровочные параметры в функции 
\lstinline{calibrationAccelerometer_calculateScaleParameters}, где алгоритм формирует матрицу ожидаемых состояний при помощи
\lstinline{calibrationAccelerometer_constructExpectedValueMatrix} и производит операции описанные в \ref{sec:domain}.

\subsubsection{Модуль калибровки гироскопа}

Модуль калибровки гироскопа использует принцип расчета среднего значения угловой скорости во время покоя и применяет
рассчитанное постоянное смещение к приходящим данным, которые представлены в виде трехкомпонентного вектора.
Инициализация и открытие модуля такая же как и в других модулях калибровки,
обратные вызовы для флэш памяти и модуля периферии реализованы также за исключением того что модуль калибровки гироскопа ожидает получения данных от гироскопа.
Состояния модуля выделяются такие же как и для модуля калибровки магнетометра.

\subsection{Модуль управления калибровкой}

Данный модуль отвечает за управление процессом калибровки устройства. Являясь промежуточным звеном между модулем калибровки и модулем \moduleUart
модуль принимает сообщения о выборе калибруемого датчика, контролирует правильную последовательность принимаемых команд, а также отменяет
калибровку если такой запрос появляется.

Функция создания дескриптора обнуляет дескриптор и возвращает адрес памяти обновленного дескриптора, далее следует открыть модуль функцией
\lstinline{businessLayer_calibrationManagerOpen} которая принимает дескрипторы модулей калибровки датчиков.

Команда, которая приходит на калибровку устройства является пакетом содержащая такую информацию как цель калибровки и состояние калибровки.
Приходящие команды от модуля UART, проверяются на то что запрос пришел не во время калибровки в функции \lstinline{isAttemptToStartNewCalibrationWhileOtherIsInProgress}.
Для акселерометра проверяются входящие состояния калибровки, что они являются валидными в функции \lstinline{isValidAccelerometerCalibrationState}.

Состояния калибровки сделаны следующие:

\begin{itemize}
    \item \lstinline{GENERAL_CALIBRATION_STATE_START} -- состояние начала калибровки;
     \item \lstinline{GENERAL_CALIBRATION_STATE_FINISH} -- состояние определяющее, что калибровка закончена успешно;
     \item \lstinline{GENERAL_CALIBRATION_STATE_ERROR} -- состояние определяющее, что калибровка закончена с ошибкой;
     \item \lstinline{GENERAL_CALIBRATION_STATE_Z_UP} -- целевое состояние калибровки акселерометра осью Z вверх;
     \item \lstinline{GENERAL_CALIBRATION_STATE_Z_DOWN} -- целевое состояние калибровки акселерометра осью Z вниз; 
     \item \lstinline{GENERAL_CALIBRATION_STATE_Y_UP} -- целевое состояние калибровки акселерометра осью Y вверх; 
     \item \lstinline{GENERAL_CALIBRATION_STATE_Y_DOWN} -- целевое состояние калибровки акселерометра осью Y вниз; 
     \item \lstinline{GENERAL_CALIBRATION_STATE_X_UP} -- целевое состояние калибровки акселерометра осью X вверх; 
     \item \lstinline{GENERAL_CALIBRATION_STATE_X_DOWN} -- целевое состояние калибровки акселерометра осью X вниз; 
\end{itemize}

Выбор устройства калибровки происходит в функции \lstinline{serveCalibration}, здесь, исходя из цели калибровки выбирается нужное. Далее если запрос не
перекрывает другие калибровки то, в случае с магнетометром и гироскопом, вызываются функции запуска калибровки: \lstinline{serveMagnetCalibration},
\lstinline{serveGyroCalibration}, их состояния определяются в начале как \lstinline{GENERAL_CALIBRATION_STATE_START} и так как калибровка происходит за один раз
то следующим успешным состоянием является \lstinline{GENERAL_CALIBRATION_STATE_FINISH}. В каждой из функции \lstinline{serveMagnet<*>}, происходит вызов соответствующих
функций согласно их API, так как функции вызова калибровки являются асинхронными то в них передается обратный вызов (для каждого вызова отдельная функция).
В случае с акселерометром все усложняется из-за способа калибровки, первое, с чего начинается калибровка -- с состояния \lstinline{GENERAL_CALIBRATION_STATE_START} и
сообщения модулю калибровки акселерометра о том, то следует перейти в соответствующее состояние. Далее после обработки команды, модуль становится в ожидание получения
от модуля UART нового пакета с верной целью и правильно установленным состоянием, иначе модуль сообщит об ошибке обратно. Так продолжается итеративно пока не закончатся
состояния, после завершения модуль модуль переходит в состояние \lstinline{GENERAL_CALIBRATION_STATE_FINISH} и ожидает поступления новых запросов.

Также предусмотрен случай отмены какой либо из калибровок, в данном случае на стороне рассматриваемого модуля меняется состояние в \lstinline{GENERAL_CALIBRATION_STATE_FINISH}.
А исходя из текущей обслуживаемой цели выбирается та цель на которую пришел запрос на отмену вместе с вызовом из API функции отмены.

\subsection{Модуль \moduleUart}

Данный модуль является одним из самых крупных модулей в программной части устройства, так как поддерживает в устройстве все задуманные команды, 
однако со стороны реализации дипломного проекта функциональная часть будет рассмотрена только в рамках дипломного проекта. Данный модуль имеет
два объекта для взаимодействия с остальным микроконтроллерами, однако будет рассмотрено взаимодействие только с одним внешним устройством, так как
для калибровки модуль общается по UART только с ним. 

Для создания модуля потребуется передать номер UART, с которым работает устройство после чего функция вернет адрес по которому располагается дескриптор.
Для инициализации модуля нужно передать созданный ранее дескриптор и передать в него дополнительные параметры, необходимые для взаимодействия с другими модулями,
в том числе и модулем управления калибровкой. Внутри происходит инициализация кольцевых буферов, которые принимают команды на линиях Rx и Tx, а также конфигурация
буфера на прием.

Основной поток работающий с командами является \lstinline{mcuCommProt_commandProcessing}, в нем происходит проверка того, есть ли что-то в буфере на прием данных
и если это так, то происходит валидация команды, а дальше ее выполнение.

Для валидации команды необходимо сверить ее с протоколом определенным между устройствами, такой протокол состоит из заголовка и собственно данных. Для нашего случая
определен заголовок: 

\begin{itemize}
    \item \lstinline{CMD_GENERAL_CALIBRATION} -- отправляемая команда на выполнение;
    \item \lstinline{LEN_GENERAL_CALIBRATION} -- длина отправляемой команды.
\end{itemize}

В качестве подтверждения получения команды предусмотрена ответная команда: 

\begin{itemize}
    \item \lstinline{RESP_GENERAL_CALIBRATION} -- возвращаемая команда;
    \item \lstinline{LEN_RESP_GENERAL_CALIBRATION} -- длина возвращаемой команды.
\end{itemize}

Пакет данных размером 2 байта представляет из себя цель калибровки и состояние калибровки, протокол так же определяет состояния, так как устройствам снаружи необходимо это знать.

После проверки размера и длины входящего пакета модуль выполняет команду \lstinline{CMD_GENERAL_CALIBRATION}, вызывая \lstinline{businessLayer_calibrationManagerServeRequestAsync},
куда и передается полезная нагрузка пакета, в частности цель и статус, а также обратный вызов, необходимый для получения ответа от модуля \moduleCalibControl.
Также предусмотрено обработка ошибки, в этом случе будет отправлен пакет с командой
\lstinline{RESP_GENERAL_CALIBRATION} и с полезной нагрузкой, где цель равна запрашиваемой цели, а состояние отмечено как \lstinline{GENERAL_CALIBRATION_STATE_ERROR}.

В случае успешной калибровки, или шага калибровки модуль \moduleCalibControl вызывает обратный вызов \lstinline{calibrationManagerCallback}, который передает команду 
\lstinline{RESP_GENERAL_CALIBRATION} и данные в виде текущей цели и статуса (положение прибора в пространстве или успешное завершение).

Также данный модуль связан с модулем \moduleOrientationAzimuth , для которого необходимы данные о текущем местоположении. В протоколе определена команда для такого случая
\lstinline{CMD_GPS_MEASUREMENTS}, c пакетом данных содержащими всю информацию от спутников. Через обратный вызов данные о GPS передаются в модуль \moduleOrientationAzimuth .

Все отправляемые команды записываются в очередь, которая опрашивается в потоке \lstinline{mcuCommProt_writeDataIfNeed} и далее отправляются по UART далее.

\subsection{Модуль \moduleMoveDetect}

\subsection{Модуль \moduleOrientationAzimuth}

\subsection{Модуль \moduleFindTarget}

\subsection{Модуль \moduleFlashMemory}

\subsection{Модуль \moduleGraphics}
