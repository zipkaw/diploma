\section{ФУНКЦИОНАЛЬНОЕ ПРОЕКТИРОВАНИЕ}
\label{sec:func}

%% TODO Описать закрытие модулей

В данном разделе модули описаны с точки зрения разработки функций, которые реализуются в
дипломном проекте. Функциональное проектирование нацелено на создание корректно и
эффективно работающего проекта. Представление необходимого функционала -- основная задача
текущего раздела. После анализа требуемых для реализации программного продукта
функций, было решено разбить программу на следующие модули:
\begin{itemize}
    \item модуль \modulePerifery;
    \item модуль \moduleCalib;
    \item модуль \moduleCalibControl;
    \item модуль \moduleUart;
    \item модуль \moduleMoveDetect;
    \item модуль \moduleOrientationAzimuth;
    \item модуль \moduleFindTarget;
    \item модуль \moduleFlashMemory;
    \item модуль \moduleGraphics.
\end{itemize}

Каждый из модулей что был описан в предыдущем разделе, будет рассмотрен более детально
в данном разделе. Для реализации каждого модуля требуется реализация определенных функций
позволяющих соответствовать модулю заявленным требованиям.
Каждая функция называется определенным способом: сначала идет название модуля в котором располагается,
далее название разделяется символом <<\_>> и описывается то что делает данная функция.

Так как ПО работает без операционной системы на микроконтроллере, взаимодействие между модулями происходит
внутри одной программы и следовательно память используется общая, поэтому важно обеспечить изолированные
области памяти для каждого модуля, для корректной работы всей программы. Делается это через закрытый интерфейс,
а наружу выдается лишь адрес дескриптора с которым работает модуль. Также из-за отсутствия ОС необходимо,
реализовать потоки и переключение контекста в системе: делается это при помощи библиотеки <<ProtoThreads>>.
Данная библиотека предоставляет единицу программной обработки, обеспечиваемая средствами языка Cи, и позволяет
не задействовать механизмы потоков операционной системы.

Каждый модуль имеет собственные сообщения ошибок, которые позволяют модулям определять их состояние на выходе функции.
Ошибки начинаются с префикса, обозначающего названия модуля, и заканчивается описанием ошибки. Все модули включают в себя следующие
ошибки (<<*>> отмечено название модуля):

\begin{itemize}
    \item \lstinline{*_OK} -- код успешного завершения функции;
    \item \lstinline{*_ERROR_UNKNOWN} -- код в случае, если ошибка не установлена, например, 
    такой код возврата может быть, в случае неопределенного поведения как исполняемого модуля, так и внешнего;
    \item \lstinline{*_ERROR_INVALID_ARGUMENT} -- код, если был подан неверный аргумент в функцию.
\end{itemize}

Остальные ошибки зависящие от реализации конкретного модуля определены в его открытом API, и содержат подробное описание ошибки.

Далее будет описана реализация каждого модуля, которая состоит из инициализации его дескриптора, функций обеспечивающих логику работы модуля
и потоков реализующих работу модуля. Помимо функциональной части модулей/подмодулей в ходе описания будут упоминаться различные атрибуты структур,
которые имеют ключевое значение в работе модуля.

Алгоритм получения и обработки данных представлен на схеме
данных \dataScheme. 
%% TODO: Add sequence diagram

\subsection{Описание работы библиотеки <<ProtoThreads>>}
%% Todo: узнать про причины использования РТ
При разработке программного обеспечения в связи с ограниченными ресурсами микроконтроллера было выбрана <<bare-metal>>
разработка -- это означает, что программа исполняется на уровне процессора, обходя слой операционной системы.
В связи с отсутствием операционной системы работа приложения может быть очень долгой из-за синхронной обработки модулем событий:
во время работы модуля, различные ожидания могут очень сильно останавливать работу других модулей и, следовательно работу всего устройства в целом.
Из-за долгих ожиданий могут теряться важные сообщения из внешнего мира и периферии.

Переход на асинхронный режим позволяет решить проблему ожиданий во время работы модуля, вводит такое понятие как переключение контекста -- переход программы
от одной задачи к другой, при этом данные в первой задаче сохраняются и ждут очереди на обработку, пока контекст снова не переключится на них. Также асинхронный
режим работы модуля позволяет делать асинхронные вызовы функций, их суть заключается в том, что в такие функции передается запрос на чтение/запись/обработку данных
и в параметры передается функция обратного вызова. Внутри асинхронных функций устанавливаются нужные флаги, и когда модуль, чей асинхронный вызов был использован,
обработает запрос, он вызовет переданную функцию обратного вызова с необходимыми данными. Модуль который обращался к асинхронной функции обработает данные переданные в обратный вызов
во время работы своего потока. Таким образом обеспечивается работа модулей только тогда, когда наступит их время выполнения, после одной итерации процесса происходит переключения контекста.

Для работы <<ProtoThreads>>, дескриптору потока, необходимо знать только адрес кода, где произошло переключение контекста. 
Примитивы для работы с потоками в качестве первого аргумента принимают дескриптор потока,
далее опционально в зависимости от того, что делает конкретный примитив.
В дипломном проектировании используются следующие примитивы библиотеки:

\begin{itemize}
    \item \lstinline{PT_INIT} -- инициализирует поток;
    \item \lstinline{PT_BEGIN} -- объявляет начало потока, данный примитив выполняет возобновление контекста(т.е. переход в то место процесса, где было совершено переключение контекста);
    \item \lstinline{PT_END} -- объявляет завершение потока;
    \item \lstinline{PT_WAIT_UNTIL} -- выполняет остановку потока, и ждет, когда условие не станет истинно, в ином случае переключает контекст;
    \item \lstinline{PT_WAIT_WHILE} -- выполняет остановку потока, и ждет, когда условие истинно, в ином случае переключает контекст;
    \item \lstinline{PT_RESTART} -- выполняет сброс потока и переключает контекст;
    \item \lstinline{PT_YIELD} -- выполняет переключение контекста, поток продолжит работу начиная место вызова этого примитива;
    \item \lstinline{PT_SPAWN} -- выполняет запуск дочернего потока и ожидает его завершения.
\end{itemize}

В ходе работы появилась необходимость, в расширении возможностей потоков, с целью улучшения читаемости кода,
поэтому на основе описанных выше примитивов были созданы новые функции управлением потоками:

\begin{itemize}
    \item \lstinline{PT_SLEEP_*} -- переводит поток в ожидание на определенное время,
    вместо <<*>> может быть указано MS либо SEC, что означает, что указанное время передано в миллисекундах или секундах соответственно.
    После истечения времени поток возобновляет работу в месте где произошло переключение контекста;
    \item \lstinline{PT_WAIT_UNTIL_WITH_TIMEOUT_*} -- ожидает выполнения пока условия с таймаутом пока оно не станет истинно
    по истечении которого выводится сообщение об истечении времени, вместо <<*>> может быть указано MS либо SEC,
    что означает, что указанное время передано в миллисекундах или секундах соответственно;
    \item \lstinline{PT_WAIT_WHILE_WITH_TIMEOUT_*} -- ожидает выполнения пока условия с таймаутом пока оно истинно
    по истечении которого выводится сообщение об истечении времени, вместо <<*>> может быть указано MS либо SEC,
    что означает, что указанное время передано в миллисекундах или секундах соответственно;
    \item \lstinline{PT_WAIT_INFINITE} -- переключает поток в зацикленный режим, необходим для того чтобы процесс был гарантированно остановлен и не мог начать работу заново;
    \item \lstinline{PT_PARENT_SANITY_CHECK_ALWAYS_N} -- выполняет проверку истинности условия в родительском потоке,
    в случае ложного условия перезапустит поток и выведет сообщение об ошибке;
    \item \lstinline{PT_CHILD_SANITY_CHECK_ALWAYS_N} -- выполняет проверку истинности условия в дочернем потоке,
    в случае ложного условия перезапустит поток и выведет сообщение об ошибке.
\end{itemize}

\nomenclaturex{SoC}{System on crystal}{система на кристалле}

\subsection{Модуль \modulePerifery}
%TODO add link to documentation
Модуль \modulePerifery\ является одной из частей блока приема и обработки
датчиков. Модуль внутри содержит драйвера для двух датчиков: магнитометра, акселерометра и гироскопа (2-в-1).

\subsubsection{Драйвер магнитометра}

Библиотека с реализацией драйвера магнитометра использует функции, структуры и перечисления,
которые начинаются с префикса \lstinline{magnetoMMC5633NJL_}, и константы, перечисления, которые начинаются с префикса \lstinline{MAGNETOMMC5633NJL_}.

Для создания дескриптора модуля используется функция
\lstinline{magnetoMMC5633NJL_create}, данная функция не принимает никаких аргументов, внутри, данная функция, сначала проверяет
был ли создан уже дескриптор, если был то функция возвращает невалидный дескриптор обозначающий ошибку его создания, в ином случае
функция обнуляет данные в памяти дескриптора \lstinline{magnetoMMC5633NJL_handle_t} и возвращает его адрес. 

Чтобы запустить модуль необходимо его открыть при помощи функции
\lstinline{magnetoMMC5633NJL_open}. В функцию открытия модуля передаются параметры необходимые для работы модуля, первый из этих параметров
 -- это адрес дескриптора модуля, описанный в структуре \lstinline{memsLSM6DSO_handle_t}, следующий параметр это дескриптор драйвера шины IIC, необходимый для конфигурации датчика и чтения оттуда данных, и последние два параметра --
это функция обратного вызова и аргумент передаваемый в эту функцию. Все параметры переданные в функцию открытия модуля сохраняются в дескрипторе магнетометра.
Помимо этого в функции происходит обнуление буфера требуемых для передачи и приема дынных по шине IIC, происходит инициализация флагов:

\begin{itemize}
    \item \lstinline{i2cThread.i2cReady} -- устанавливается в \lstinline{true}, означает, что шина готова принимать и передавать данные;
    \item \lstinline{isOpened} -- устанавливается в \lstinline{true}, означает, что модуль начал инициализацию;
    \item \lstinline{isOpenFinished} -- устанавливается в \lstinline{false}, означает, что модуль не закончил процесс инициализации;
    \item \lstinline{isCloseFinished} -- устанавливается в \lstinline{false}, означает, что модуль не закончил процесс остановки (закрытия).
\end{itemize}

Далее чтобы начать модулю работать необходимо проинициализировать потоки:

\begin{itemize}
    \item \lstinline{singleMeasurementPt} -- дескриптор основного потока \lstinline{magnetoMMC5633NJL_singleMeasurement_thread} в котором модуль читает данные от датчика;
    \item \lstinline{readIdentifierPt} -- дескриптор дочернего потока \lstinline{magnetoMMC5633NJL_readIdentifier} для чтения идентификатора датчика;
    \item \lstinline{selfTestPt} --  дескриптор дочернего потока \lstinline{magnetoMMC5633NJL_selfTest} для операции самотестирования;
    \item \lstinline{readBurstBlockingPt} --  дескриптор дочернего потока \lstinline{magnetoMMC5633NJL_readBurstBlocking} для чтения информации с шины IIC в буфер;
    \item \lstinline{writeBurstBlockingPt} --  дескриптор дочернего потока \lstinline{magnetoMMC5633NJL_writeBurstBlocking} для записи информации в датчик;
    \item \lstinline{softwareResetPt} --  дескриптор дочернего потока \lstinline{magnetoMMC5633NJL_softwareReset} для программного сброса датчика.
\end{itemize}

Для окончания инициализации модуля, нужно провести операцию самотестирования с целью определения корректности работы датчика. После данной операции
будет считаться, что модуль проинициализирован и готов к измерениям, флаг дескриптора магнетометра, \lstinline{isOpenFinished}, установится в \lstinline{true}.
За это отвечает поток открытия \lstinline{magnetoMMC5633NJL_openFinalize_thread}, вначале, поток ожидает когда модуль начнет инициализацию в вызове \lstinline{magnetoMMC5633NJL_open},
после установки флага \lstinline{isOpened} -- устанавливается в \lstinline{true} поток запускает дочерний поток \lstinline{magnetoMMC5633NJL_readIdentifier} 
при помощи \lstinline{PT_SPAWN}, который вычитывает идентификатор из регистра и сверяет его с тем идентификатором, что определен в документации на датчик.

После завершения чтения идентификатора модуль проверяет статус чтения при помощи \lstinline{PT_PARENT_SANITY_CHECK_ALWAYS_N}. Далее
если идентификатор прочитан успешно происходит операция самотестирования. Но перед этим требуется совершить программный сброс датчика
при помощи запуска потока \lstinline{magnetoMMC5633NJL_softwareReset},
делается это для сброса управляющего регистра датчика. Если сброс прошел успешно, то модуль готов для операции самотестирования, 
которая происходит в потоке \lstinline{magnetoMMC5633NJL_selfTest}.
Данный поток сначала считывает данные записанные в регистре для самотестирования \lstinline{MAGNETOMMC5633NJL_ST_START_ADDR},
далее согласно документации 
нужно найти 80\% от этих данных и записать их в регистр \lstinline{THR_ST_START_ADDR} после записи в управляющий регистр нужно установить флаги
\lstinline{MAGNET_CONTROL0_TAKE_MEAS_M_MASK | MAGNET_CONTROL0_AUTO_ST_EN_MASK}
и прочитать регистр \lstinline{STATUS_REG} хранящий статус датчика.
Если
бит \lstinline{SAT_SENSOR_MASK} установлен в ноль, то считается,
что датчик работает корректно, модуль закончил процесс инициализации и флаг \lstinline{isOpenFinished} устанавливается в \lstinline{true}.

Когда модуль проинициализирован и установлен флаг \lstinline{isOpenFinished} в \lstinline{true}, поток \lstinline{magnetoMMC5633NJL_singleMeasurement_thread},
считывающий данные с датчика, начинает свою работу. Перед чтением устанавливается флаг \lstinline{MAGNET_CONTROL0_TAKE_MEAS_M_MASK}, означающий провести измерениям,
и флаг \lstinline{MAGNET_CONTROL0_AUTO_SR_EN_MASK}, означающий, что после чтения данных, будут записаны новые. После установки флагов
из регистр статуса \lstinline{MAGNETOMMC5633NJL_STATUS_REG}, проверяется бит \lstinline{MAGNET_STATUS1_MEAS_M_DONE}, установка которого в 1 говорит о
готовности данных. Далее происходит вычитывание данных из регистров начиная с регистра \lstinline{MAGNETOMMC5633NJL_MEAS_START_ADDR} и масштабирование полученных данных
к реальным физическим величинам, в нашем случае это гауссы, и отправка этих данных далее в модуль, с которым модуль магнетометра связан обратным вызовом.
Данные об измерениях хранятся в структуре \lstinline{magnetoMMC5633NJL_measurements_t} и содержит измерения магнитного поля земли по трём осям.

Для того чтобы остановить поток обработки и сам драйвер используется функция \lstinline{magnetoMMC5633NJL_close}, которая может вернуть ошибку если модуль находится в процессе открытия
или уже закрыт. Также дескриптор может быть удален \lstinline{magnetoMMC5633NJL_delete}.

\subsubsection{Драйвер акселерометра/гироскопа}
%TODO: Add link to documentation
Библиотека с реализацией драйвера магнитометра использует функции, структуры,
которые начинаются с префикса \lstinline{memsLSM6DSO_}, и константы, перечисления, которые начинаются с префикса \lstinline{MEMSLSM6DSO_}.
Особенность драйвера в том, что он состоит получает данные сразу от гироскопа и акселерометра, сделано так из-за
того, что датчик является устройством два-в-одном и содержит два сенсора, создавать два отдельных драйвера нецелесообразно:
\begin{itemize}
    \item количество кода будет больше, из-за двух функций открытия/закрытия и двух потоков, вместо всего по одному;
    \item драйвер содержит FIFO буфер, который удобнее читать из одного места, вместо двух, так как он помещает данные
    измеренные в один момент времени от двух датчиков;
\end{itemize}

\nomenclaturex{FIFO}{First in first out}{очередь с организацией первый вошел первый вышел}

Создание дескриптора для дальнейшей работы драйвера начинается с функции \lstinline{memsLSM6DSO_create}, в
которой происходит очистка 
дескриптора, проверка, не было ли создан, данный дескриптор в процессе работы программы.
Функция возвращает адрес созданного дескриптора \lstinline{memsLSM6DSO_handle_t}.

Как и в случае с драйвером магнетометра, требуется открытие модуля и инициализация потоков, ответственных за
работу модуля. Функция \lstinline{memsLSM6DSO_open} принимает дескриптор драйвера шины IIC, функцию обратного вызова
и агрумент этой функции. В функции инициализируются дескрипторы следующих потоков:

\begin{itemize}
    \item \lstinline{singleMeasurementPt} -- дескриптор основного потока \lstinline{memsLSM6DSO_singleMeasurement_thread} в котором модуль читает данные от датчика;
    \item \lstinline{readIdentifierPt} -- дескриптор дочернего потока \lstinline{memsLSM6DSO_readIdentifier} для чтения идентификатора датчика;
    \item \lstinline{readBurstBlockingPt} --  дескриптор дочернего потока \lstinline{memsLSM6DSO_readBurstBlocking} для чтения информации с шины IIC в буфер;
    \item \lstinline{writeBurstBytePt} --  дескриптор дочернего потока \lstinline{memsLSM6DSO_readBurstBlocking} для чтения информации с шины IIC в буфер;
    \item \lstinline{writeBurstBlockingPt} --  дескриптор дочернего потока \lstinline{memsLSM6DSO_writeBurstBlocking} для записи информации в датчик;
    \item \lstinline{softwareResetPt} --  дескриптор дочернего потока \lstinline{memsLSM6DSO_softwareReset} для программного сброса датчика.
\end{itemize}

Для работы модуля нужно установить следующие флаги:

\begin{itemize}
    \item \lstinline{fifoHandle.modeFIFO} -- устанавливается \lstinline{FIFO_MODE_DEF},
    означает, что FIFO останавливает прием данных при полном заполнении и устанавливает текущий период записи данных в FIFO;
    \item \lstinline{fifoHandle.bypassFIFO} -- устанавливается в \lstinline{FIFO_BYPASS}, означает, что FIFO;
    \item \lstinline{i2cThread.i2cReady} -- устанавливается в \lstinline{true}, означает, что шина готова принимать и передавать данные;
    \item \lstinline{isOpened} -- устанавливается в \lstinline{true}, означает, что модуль начал инициализацию;
    \item \lstinline{isOpenFinished} -- устанавливается в \lstinline{false}, означает, что модуль не закончил процесс инициализации;
    \item \lstinline{isCloseFinished} -- устанавливается в \lstinline{false}, означает, что модуль не закончил процесс остановки (закрытия).
\end{itemize}


\begin{table}[ht]
    \caption{Конфигурационные параметры датчика}
    \label{table:func:memsConf}
    \begin{tabular}{| >{\raggedright}m{0.2\textwidth}
                    | >{\raggedright}m{0.36\textwidth}
                    | >{\raggedright\arraybackslash}m{0.380\textwidth}|}
        \hline
        \centering Регистр & \centering Параметр & \centering\arraybackslash Описание \\
  
        \hline
        \lstinline[]$CTRL9_XL$ & 
        \lstinline[]$I3C_DISABLE$ & 
        Отключение режима работы по шине I3C
        \\  
        \hline
        \lstinline[]$FIFO_CTRL1$ & 
        \lstinline[]$FIFO_WATERMARK$& 
        Определяет размер буфера равным 6 байт
        \\  
        \hline
        \lstinline[]$FIFO_CTRL2$ & 
        \lstinline[]$FIFO_STOP_ON_WTM$ & 
        Включает ограничение размера буфера до установленного
        \\  
        \hline
        \lstinline[]$FIFO_CTRL3$ & 
        \lstinline[]$FIFO_BDR$ & 
        Устанавливает частоту записи данных в буфер равной 12,5 Гц
        \\  
        \hline
        \lstinline[]$CTRL10_C$ & 
        \lstinline[]$TIMESTAMP_ENABLE$ & 
        Включение разницы времени между измерениями
        \\
        \hline
        \lstinline[]$CTRL1_XL$ & 
        \lstinline[]$XL_ODR_12_5Hz_4g$ & 
        Установка частоты измерений акселерометра равной 12,5 Гц, а также амплитуду измерений равной 4 g
        \\
        \hline
        \lstinline[]$CTRL2_G$ & 
        \lstinline[]$G_ODR_12_5Hz_250dps$ & 
        Установка частоты измерений гироскопа 12,5 Гц, а также амплитуду измерений равной 250 град./сек.
        \\
        \hline
    \end{tabular}
  \end{table}

После модулю необходимо завершить инициализацию в потоке \lstinline{memsLSM6DSO_openFinalize_thread}, в котором на старте для проверки вычитывается
идентификатор датчика  -- успешно считанный идентификатор говорит о корректной работе устройства. Далее происходит сброс вызовом потока
\lstinline{memsLSM6DSO_softwareReset} и последовательно записывается конфигурация устройства, в таблице \ref{table:func:memsConf} описано назначение
каждого регистра и параметра записываемого в него.

После успешной конфигурации устройство считается готовым к работе, выставляется флаг \lstinline{isOpenFinished} в \lstinline{true}, и начинает
работать основной поток \lstinline{memsLSM6DSO_singleMeasurement_thread}. Чтение измерений начинается с записи в регистр \lstinline{FIFO_CTRL4}
параметров из дескриптора: \lstinline{fifo.modeFIFO} для начала записи новых данных.
Чтение из FIFO сначала выполняется чтением статуса, содержащем информацию о размере буфера. После вычитывается регистр меток
который содержит номер текущей метки и метку о том какие измерения лежат в буфере (акселерометра/гироскопа). 
Далее проверяется, что номер метки читаемых данных не совпадает с номером метки текущих данных,
и в соответствии с меткой читаются данные в структуру дескриптора \lstinline{memsLSM6DSO_measurements_t}, что содержит измерения акселерометра и гироскопа и время между измерениями.
После успешного чтения поток сначала масштабирует данные к физическим величинам, вычитывает
метку времени с ее корректировкой согласно документации на датчик, и очищает буфер при помощи параметра указанного в \lstinline{fifo->bypassFIFO}.
И в конце поток выполняет обратный вызов с данными лежащими в структуре \lstinline{memsLSM6DSO_measurements_t}, что содержит измерения акселерометра и гироскопа и время между измерениями.

Для того чтобы остановить поток обработки и сам драйвер используется функция \lstinline{memsLSM6DSO_close}, которая может вернуть ошибку если модуль находится в процессе открытия
или уже закрыт. Также дескриптор может быть удален \lstinline{memsLSM6DSO_delete}.

\subsection{Модуль калибровки}

Ключевой модуль в проекте -- это модуль калибровки, он отвечает за преобразование искаженных различными факторами данных, в вид близкий к действительности. 
Данный модуль состоит из подмодулей ориентированных на каждый датчик и реализует в себе алгоритмы калибровки описанные в разделе \ref{sec:domain}.
Ниже будет рассмотрено более детальнее функциональная реализация каждого из модуля.

\subsubsection{Модуль калибровки магнетометра}

За создание дескриптора модуля отвечает функция \lstinline{calibrationMagnetometerCreate}, внутри происходит обнуление дескриптора,
инициализация потоков и возврат адреса памяти на которую указывает структура. Далее происходит открытие модуля при помощи функции 
\lstinline{calibrationMagnetometerOpen}. Функция принимает собственно дескриптор \lstinline{calibrationMagnetometer_t},
дескриптор флэш-памяти, сектор памяти куда будут записаны калибровочные параметры, а также функция обратного вызова и ее аргумент, 
которая связывает модули и позволяет асинхронно передавать данные дальше. Функция собственно сохраняет в дескриптор функцию обратного вызова с ее агрументом,
а также сохраняет дескритор флэш-памяти вместе с сектором для дальнейшей работы с модулем \moduleFlashMemory. 

Дл чтения параметров из флэш-памяти определены следующие состояния определенные в \lstinline{flashRequestToReadParameters_t}:

\begin{enumerate_num}
    \item \lstinline{CALIBRATION_REQUEST_FOR_PARAMETERS} -- запрос к флэш памяти на чтение данных.
    \item \lstinline{CALIBRATION_PARAMETERS_WAS_READ_SUCCESS} -- чтение прошло успешно.
    \item \lstinline{CALIBRATION_PARAMETERS_WAS_READ_FAIL} -- чтение завершилось ошибкой (из-за ошибки флэш памяти либо неверного кода crc32).
\end{enumerate_num}

Работа основного потока модуля определяется состояниями конечного автомата, которые определены в \lstinline{internalCommands_t} и перечисленны ниже:

\begin{enumerate_num}
    \item \lstinline{CALIBRATION_APPLY_CALIBRATION} -- состояние, когда модуль принимает данные от магнетометра и калибрует их своими параметрами.
    \item \lstinline{CALIBRATION_RECALIBRATE} -- состояние, когда магнитометр начинает калиброваться.
    \item \lstinline{CALIBRATION_RESET_TO_DEFAULTS} -- состояние, когда модуль не смог вычитать параметры из флэш памяти, и читает стандартные.
    \item \lstinline{CALIBRATION_RECALIBRATE_CANCEL} -- пришла команда на отмену калибровки модуля.
\end{enumerate_num}

Так как модуль получает асинхронно данные от модулей \modulePerifery~и \moduleFlashMemory , то в себе модуль имеет реализации функций обратного вызова для соответствующих модулей.
Реализация обратного вызова для \modulePerifery~ориентирована на получение данных от драйвера магнетометра и обращается к структуре \lstinline{magnetoCb_t},
в которой перечисленны данные от магнетометра в структуре \lstinline{calibrationMagnetometerInputMeasurements_t}, флаг того что данные были вычитаны \lstinline{magnetoWasRead}.
и код ошибки магнетометра \lstinline{error}. Данная структура является атрибутом дескриптора. Функция обратного вызова \lstinline{calibrationMagnetometerCallback} 
со стороны модуля калибровки магнетометра ожидает получение своего дескриптора, и кода ошибки. В функции устанавливаются флаг и данные от магнетометра.

Для связи с модулем \moduleFlashMemory~ используется обратный вызов \lstinline{flashCb}, данный обратный вызов ожидает получить дескриптор модуля калибровки магнетометра, код ошибки,
и количество прочитанных байт. Для хранения информации от обратного вызова модуль содержит структуру с данными, которые получает функция, а также устанавливает флаг \lstinline{flashIsReady}.

Главный поток работает по состояниям из \lstinline{flashRequestToReadParameters_t} и \lstinline{internalCommands_t}. И зависимости от состояний
поток вычитывает дынные из флэш памяти используя дочерний поток \lstinline{readParametersFromFlash}, который вычитывает данные и проверяет их корректность,
либо ожидает данные от магнитометра и применяет калибровочные параметры и вызывает функцию обратного вызова другого модуля, где в качестве аргумента передает откалиброванные измерения,
либо обрабатывает команду на калибровку, генерируя дочерний поток \lstinline{recalibrateCommandRoutine}, либо останавливает поток по команде, либо сбрасывает параметры инициализируя модуль
стандартными определенными параметрами.

Состояние \lstinline{CALIBRATION_REQUEST_FOR_PARAMETERS} является для модуля начальным, модуль может перейти в состояние \lstinline{CALIBRATION_PARAMETERS_WAS_READ_SUCCESS} и в процессе работы это состояние
будет для модуля конечным по части работы с модулем \moduleFlashMemory, либо в состояние \lstinline{CALIBRATION_PARAMETERS_WAS_READ_FAIL},
в котором модуль перейдет в состояние \lstinline{CALIBRATION_RESET_TO_DEFAULTS}, и вычитает стандартные
параметры и перейдет в состояние модуля калибровки данных от модуля калибровки магнитометра: \lstinline{CALIBRATION_APPLY_CALIBRATION}.
Если поступит команда на калибровку, то модуль переключится в состояние \lstinline{CALIBRATION_RECALIBRATE}, после которого модуль в любом случае переключится в состояние
\lstinline{CALIBRATION_APPLY_CALIBRATION}.

\subsubsection{Модуль калибровки акселерометра}

Модуль реализует математический способ калибровки описанный в \ref{sec:domain}, а также реализует механизм организации последовательности считывания данных и калибровку
текущих значений. 

Инициализация и открытие модуля калибровки акселерометра аналогична тому, как это делается в модуле калибровки магнитометра. Меняется только дескриптор описанный в данном модуле.
Связан модуль с другими модулями также как и в предыдущем случае, только сейчас на вход от модуля \modulePerifery ожидаются данные акселерометра.

Для работы модуля также необходимы состояния, которые используются в потоке и определены в \lstinline{calibrationAccelerometer_internalCommands_t}:

\begin{enumerate_num}
    \item \lstinline{CALIBRATION_ACCELEROMETER_APPLY_CALIBRATION} -- стандартное состояние калибровки входных данных.
    \item \lstinline{CALIBRATION_ACCELEROMETER_RECALIBRATE} -- состояние в котором прибор начинает операцию калибровки.
    \item \lstinline{CALIBRATION_ACCELEROMETER_WAIT_NEW_POS} -- ожидание установки нового определенного положения.
    \item \lstinline{CALIBRATION_ACCELEROMETER_SET_POS} -- сбор данных на установленной позиции.
    \item \lstinline{CALIBRATION_ACCELEROMETER_RESET_TO_DEFAULTS} -- сброс калибровочных параметров.
    \item \lstinline{CALIBRATION_ACCELEROMETER_RECALIBRATE_CANCEL} -- отмена калибровки прибора.
\end{enumerate_num}

В случае калибровки, необходимо определять положение прибора, в документации к использованию прибора приведена последовательность положений прибора,
в программной части идет такая же последовательность и описана в \lstinline{calibrationAccelerometerStates_t}:

\begin{enumerate_num}
    \item \lstinline{CALIBRATION_ACCELEROMETER_POSITION_Z_UP} -- описывает положение осью Z вверх.
    \item \lstinline{CALIBRATION_ACCELEROMETER_POSITION_Z_DOWN} -- описывает положение осью Z вверх.
    \item \lstinline{CALIBRATION_ACCELEROMETER_POSITION_Y_UP} -- описывает положение осью Y вверх.
    \item \lstinline{CALIBRATION_ACCELEROMETER_POSITION_Y_DOWN} -- описывает положение осью Y вверх.
    \item \lstinline{CALIBRATION_ACCELEROMETER_POSITION_X_UP} -- описывает положение осью X вверх.
    \item \lstinline{CALIBRATION_ACCELEROMETER_POSITION_X_DOWN} -- описывает положение осью X вверх.
    \item \lstinline{CALIBRATION_ACCELEROMETER_POSITION_FINISH} -- определяет, что все данные собраны и устройство подсчитывает параметры.
    \item \lstinline{CALIBRATION_ACCELEROMETER_CALIBRATION_FINISHED} -- определяет, что параметры были сохранены и записаны в флэш память.
\end{enumerate_num}

Состояния для взаимодействия с флэш памятью определены такие же как и в модуле калибровки магнетометра. 

Хоть и многое повторяется в данном модуле как и в модуле калибровки магнетометра, однако следует выделить,
то что модуль требователен к взаимодействию с пользователем и проверкой корректности
установки нового положения. Данный модуль не отвечает за это, в его случае требуется только знать о том, что состояние было установлено. Ответственность
за правильную последовательность отводится модулю \moduleCalibControl . Это было сделано для удобного использования управлением калибровкой устройства по
UART через один управляющий модуль. Управление за входящие сообщения об установке новой позиции принимает \lstinline{calibrationAccelerometerPositionWasSetCb},
он отслеживает три состояния в котором находится калибровка:

\begin{itemize}
    \item \lstinline{CALIBRATION_ACCELEROMETER_RECALIBRATE} -- в данном состоянии модуль начинает калибровку, то есть предполагается, модуль находится в начальном положении;
    \item \lstinline{CALIBRATION_ACCELEROMETER_WAIT_NEW_POS} -- в данном случае модуль устанавливает новую позицию;
    \item \lstinline{CALIBRATION_ACCELEROMETER_SET_POS} -- в данном случае прерывается текущий сбор данных и происходит переключение в следующую позицию.
\end{itemize}


Каждое изменение состояния отслеживает основной поток, первое, что делает поток в начале работы -- читает параметры из флэш памяти и после успешного прочтения переходит в состояние
\lstinline{CALIBRATION_ACCELEROMETER_APPLY_CALIBRATION}, если же параметры были вычитаны неверные, то поток переходит в состояние
сброса калибровочных параметров, сбрасывает значения и записывает их обратно во флэш память, после переходит обратно в состояние
\lstinline{CALIBRATION_ACCELEROMETER_APPLY_CALIBRATION}. По приходу команды \lstinline{CALIBRATION_ACCELEROMETER_RECALIBRATE}, поток только
собирает данные.
После получения измерений всех позиций модуль переходит в состояние \lstinline{CALIBRATION_ACCELEROMETER_POSITION_FINISH} и поток начинает рассчитывать калибровочные параметры в функции 
\lstinline{calibrationAccelerometer_calculateScaleParameters}, где алгоритм формирует матрицу ожидаемых состояний при помощи
\lstinline{calibrationAccelerometer_constructExpectedValueMatrix} и производит операции описанные в разделе \ref{sec:domain}.

\subsubsection{Модуль калибровки гироскопа}

Модуль калибровки гироскопа использует принцип расчета среднего значения угловой скорости во время покоя и применяет
рассчитанное постоянное смещение к приходящим данным, которые представлены в виде трехкомпонентного вектора.
Инициализация и открытие модуля такая же как и в других модулях калибровки,
обратные вызовы для флэш памяти и модуля периферии реализованы также за исключением того что модуль калибровки гироскопа ожидает получения данных от гироскопа.
Состояния модуля выделяются такие же как и для модуля калибровки магнетометра.

\subsection{Модуль управления калибровкой}

Данный модуль отвечает за управление процессом калибровки устройства. Являясь промежуточным звеном между модулем калибровки и модулем \moduleUart
модуль принимает сообщения о выборе калибруемого датчика, контролирует правильную последовательность принимаемых команд, а также отменяет
калибровку если такой запрос появляется.

Функция создания дескриптора обнуляет дескриптор и возвращает адрес памяти обновленного дескриптора, далее следует открыть модуль функцией
\lstinline{calibrationManagerOpen} которая принимает дескрипторы модулей калибровки датчиков.

Команда, которая приходит на калибровку устройства является пакетом содержащая такую информацию как цель калибровки и состояние калибровки.
Приходящие команды от модуля UART, проверяются на то что запрос пришел не во время калибровки в функции \lstinline{isAttemptToStartNewCalibration}.
Для акселерометра проверяются входящие состояния калибровки, что они являются валидными в функции \lstinline{isValidAccelerometerCalibrationState}.

Состояния калибровки сделаны следующие:

\begin{itemize}
    \item \lstinline{GENERAL_CALIBRATION_START} -- состояние начала калибровки;
     \item \lstinline{GENERAL_CALIBRATION_FINISH} -- состояние определяющее, что калибровка закончена успешно;
     \item \lstinline{GENERAL_CALIBRATION_ERROR} -- состояние определяющее, что калибровка закончена с ошибкой;
     \item \lstinline{GENERAL_CALIBRATION_Z_UP} -- целевое состояние калибровки акселерометра осью Z вверх;
     \item \lstinline{GENERAL_CALIBRATION_Z_DOWN} -- целевое состояние калибровки акселерометра осью Z вниз; 
     \item \lstinline{GENERAL_CALIBRATION_Y_UP} -- целевое состояние калибровки акселерометра осью Y вверх; 
     \item \lstinline{GENERAL_CALIBRATION_Y_DOWN} -- целевое состояние калибровки акселерометра осью Y вниз; 
     \item \lstinline{GENERAL_CALIBRATION_X_UP} -- целевое состояние калибровки акселерометра осью X вверх; 
     \item \lstinline{GENERAL_CALIBRATION_X_DOWN} -- целевое состояние калибровки акселерометра осью X вниз.
\end{itemize}

Выбор устройства калибровки происходит в функции \lstinline{serveCalibration}, здесь, исходя из цели калибровки выбирается нужное. Далее если запрос не
перекрывает другие калибровки то, в случае с магнетометром и гироскопом, вызываются функции запуска калибровки: \lstinline{serveMagnetCalibration},
\lstinline{serveGyroCalibration}, их состояния определяются в начале как \lstinline{GENERAL_CALIBRATION_START} и так как калибровка происходит за один раз
то следующим успешным состоянием является \lstinline{GENERAL_CALIBRATION_FINISH}. В каждой из функции \lstinline{serveMagnet<*>}, происходит вызов соответствующих
функций согласно их API, так как функции вызова калибровки являются асинхронными то в них передается обратный вызов (для каждого вызова отдельная функция).
В случае с акселерометром все усложняется из-за способа калибровки, первое, с чего начинается калибровка -- с состояния \lstinline{GENERAL_CALIBRATION_START} и
сообщения модулю калибровки акселерометра о том, то следует перейти в соответствующее состояние. Далее после обработки команды, модуль становится в ожидание получения
от модуля UART нового пакета с верной целью и правильно установленным состоянием, иначе модуль сообщит об ошибке обратно. Так продолжается итеративно пока не закончатся
состояния, после завершения модуль модуль переходит в состояние \lstinline{GENERAL_CALIBRATION_FINISH} и ожидает поступления новых запросов.

Также предусмотрен случай отмены какой либо из калибровок, в данном случае на стороне рассматриваемого модуля меняется состояние в \lstinline{GENERAL_CALIBRATION_FINISH}.
А исходя из текущей обслуживаемой цели выбирается та цель на которую пришел запрос на отмену вместе с вызовом из API функции отмены.

\subsection{Модуль \moduleUart}

Данный модуль является одним из самых крупных модулей в программной части устройства, так как поддерживает в устройстве все задуманные команды, 
однако со стороны реализации дипломного проекта функциональная часть будет рассмотрена только в рамках дипломного проекта. Данный модуль имеет
два объекта для взаимодействия с остальным микроконтроллерами, однако будет рассмотрено взаимодействие только с одним внешним устройством, так как
для калибровки модуль общается по UART только с ним. 

Для создания модуля потребуется передать номер UART, с которым работает устройство после чего функция вернет адрес по которому располагается дескриптор.
Для инициализации модуля нужно передать созданный ранее дескриптор и передать в него дополнительные параметры, необходимые для взаимодействия с другими модулями,
в том числе и модулем управления калибровкой. Внутри происходит инициализация кольцевых буферов, которые принимают команды на линиях Rx и Tx, а также конфигурация
буфера на прием.

Основной поток работающий с командами является \lstinline{mcuCommProt_commandProcessing}, в нем происходит проверка того, есть ли что-то в буфере на прием данных
и если это так, то происходит валидация команды, а дальше ее выполнение.

Для валидации команды необходимо сверить ее с протоколом определенным между устройствами, такой протокол состоит из заголовка и собственно данных. Для нашего случая
определен заголовок: 

\begin{itemize}
    \item \lstinline{CMD_GENERAL_CALIBRATION} -- отправляемая команда на выполнение;
    \item \lstinline{LEN_GENERAL_CALIBRATION} -- длина отправляемой команды.
\end{itemize}

В качестве подтверждения получения команды предусмотрена ответная команда: 

\begin{itemize}
    \item \lstinline{RESP_GENERAL_CALIBRATION} -- возвращаемая команда;
    \item \lstinline{LEN_RESP_GENERAL_CALIBRATION} -- длина возвращаемой команды.
\end{itemize}

Пакет данных размером 2 байта представляет из себя цель калибровки и состояние калибровки, протокол так же определяет состояния, так как устройствам снаружи необходимо это знать.

После проверки размера и длины входящего пакета модуль выполняет команду \lstinline{CMD_GENERAL_CALIBRATION}, вызывая \lstinline{calibrationManagerServeRequestAsync},
куда и передается полезная нагрузка пакета, в частности цель и статус, а также обратный вызов, необходимый для получения ответа от модуля \moduleCalibControl.
Также предусмотрено обработка ошибки, в этом случе будет отправлен пакет с командой
\lstinline{RESP_GENERAL_CALIBRATION} и с полезной нагрузкой, где цель равна запрашиваемой цели, а состояние отмечено как \lstinline{GENERAL_CALIBRATION_ERROR}.

В случае успешной калибровки, или шага калибровки модуль \moduleCalibControl вызывает обратный вызов \lstinline{calibrationManagerCallback}, который передает команду 
\lstinline{RESP_GENERAL_CALIBRATION} и данные в виде текущей цели и статуса (положение прибора в пространстве или успешное завершение).

Также данный модуль связан с модулем \moduleOrientationAzimuth , для которого необходимы данные о текущем местоположении. В протоколе определена команда для такого случая
\lstinline{CMD_GPS_MEASUREMENTS}, c пакетом данных содержащими всю информацию от спутников. Через обратный вызов данные о GPS передаются в модуль \moduleOrientationAzimuth .

Все отправляемые команды записываются в очередь, которая опрашивается в потоке \lstinline{mcuCommProt_writeDataIfNeed} и далее отправляются по UART далее.

\subsection{Модуль \moduleOrientationAzimuth}

Данный модуль реализует в себе использование фильтра Мэджвика, поправку на наклонение устройства и учет магнитного наклонения.
В работе данный алгоритм проверяет одновременно ли получены данные от акселерометра, гироскопа и магнетометра -- это важно для алгоритма Мэджвика.
После вычисляет все необходимые параметры, такие как азимут и ориентацию в пространстве. 

Модуль начинает работу с создания дескриптора, таким же способом как это было описано ранее. В функции инициализации модуля
функция принимает обратный вызов который связывает рассматриваемый модуль вместе с модулями поиска цели и отображения на экране.
Во время инициализации происходит настройка фильтра Мэджвика, и пометка невалидности всех данных (чтобы поток не вернул неверные данные в начале работы).

За прием данных от модулей калибровки отвечают функции:
\begin{itemize}
    \item \lstinline{updateAccelerometerMeasurements} -- проверяет корректность данных акселерометра и обновляет внутренний дескриптор входящими данными;
    \item \lstinline{updateGyroscopeMeasurements} -- проверяет корректность данных гироскопа и обновляет внутренний дескриптор входящими данными;
    \item \lstinline{updateGPSMeasurements} -- проверяет корректность данных GPS и обновляет внутренний дескриптор входящими данными;
    \item \lstinline{updateMagnetometerMeasurements} -- проверяет корректность данных магнетометра и обновляет внутренний дескриптор входящими данными.
\end{itemize}


В процессе работы потока проверяется, пришли ли новые данные в функции \lstinline{isTimeToUpdateAlgorithm}, в которой также проверяется были получены данные в
одно время. Если данные были получены, то требуется обновить данные фильтра Мэджвика. После обновления можно получить новые данные с поправками, которые в функции
\lstinline{computeTiltCompensation} рассчитывают компенсацию на наклонения прибора, в \lstinline{computeDeclination} рассчитывают  магнитное наклонение, в функции
\lstinline{computeDevicePosition} высчитывают ориентацию прибора в пространстве переводя данные из кватернионов в углы Эйлера.

\subsection{Модуль \moduleMoveDetect}

Данный модуль отвечает за определение вращательного движения пользователем, целью реализации данного модуля состоит в том чтобы решить проблему случайных движений не
приводящих к появлению случайных событий. Для этого был рассчитан и реализован БИХ ФНЧ по формуле из \ref{sec:domain}. Особенность реализации данного фильтра состоит в том,
что он содержит необходимые задержи во время движения, отсекая тем самым резкие и случайные движения во время работы с приором. 

Реализация состоит из создания дескриптора, его инициализации функцией \lstinline{deviceMoveDetectorOpen} вместе с параметром обратного вызова от модуля
отображения.

Для определения текущего состояние используются следующие перечисления:

\begin{itemize}
    \item \lstinline{BUSINESS_LAYER_MOVE_DETECTOR_MOVE} -- определяет, что прибор находится в движении;
    \item \lstinline{BUSINESS_LAYER_MOVE_DETECTOR_NOT_MOVE} -- определяет, что прибор не движется; 
    \item \lstinline{BUSINESS_LAYER_MOVE_DETECTOR_INITIALIZATION} -- определяет, что прибор находится в стадии инициализации.
\end{itemize}

В начале работы фильтр находится в состоянии \lstinline{BUSINESS_LAYER_MOVE_DETECTOR_INITIALIZATION} и основной поток вызывает функцию
\lstinline{deviceMoveDetectorFilterStep}, в которой происходит обновление фильтра пока данные не станут стабильные.
После этого поток может находится в двух состояниях \lstinline{BUSINESS_LAYER_MOVE_DETECTOR_MOVE} и \lstinline{BUSINESS_LAYER_MOVE_DETECTOR_NOT_MOVE}.
За определение перемещения отвечает функция \lstinline{deviceMoveDetectorRecognizeState}, которая вызывается в потоке после состояния инициализации.
Внутри ее перебираются значения для каждой оси вычисляются обновленные фильтром значения. Функция \lstinline{deviceMoveDetectorIIRFilter} реализует в себе
БИХ ФНЧ. В случае если результат превышает порог заданный в \lstinline{BUSINESS_LAYER_MOVE_DETECTOR_GYRO_THRESHOLD}, то отправляется состояние \lstinline{BUSINESS_LAYER_MOVE_DETECTOR_MOVE}.

\subsection{Модуль \moduleFindTarget}

Данный модуль принимает информацию о азимуте от модуля \moduleOrientationAzimuth, 
текущей позиции и позиции цели от модуля \moduleUart, функция инициализации устанавливает все состояния цели на экране как невалидные
целью, чтобы при старте потока отображения не было не правильной информации на экране. 

Для расчета позиции цели используется функция поиска разницы азимутов используя позиции цели и устройства. На основе данной разницы
определяется текущее поле зрения прибора пересчитанное в дискретной области экрана, то есть на какой позиции экрана находится цель.

Все вычисленные данные передаются дальше в модуль \moduleGraphics.

\subsection{Модуль \moduleGraphics}

В дипломном проекте данный модуль, выводящий полезную графическую информацию пользователю, и состоит из нескольких частей: первая из них ответственна за хранение
изображений, данные представляют из себя двумерный массив и описывают заранее сгенерированный динамический объект, следующая часть заключается в определении иконки
которая будет отрисована, и заключительная часть -- это поток отрисовки, обеспечивающий плавное и динамическое отображение на экране. Данный модуль
сильно абстрагирован от работы драйверов видеопотока, необходимый минимум для отображения графики -- это память куда будут записаны данные и функция инвалидации кэша.
Адрес памяти представляет заранее определенную в платформе область, которая является общей для видеопотока и модуля графики, обмен данными между модулями
обеспечивает DMA модуль, дальше, после DMA драйвер видеопотока отображает необхоимые данные на определенном слое. Работа драйвера не рассматривается, так как это выходит за рамки
реализации темы дипломного проекта. Инвалидация кэша необходима для избегания случаев отрисовки предыдущей записанной информации, работа с инвалидацией происходит через драйвера
поставляемого SoC.

Для данного модуля определены два дескриптора, в нашем случае используется дескриптор для строки состояния и при помощи функции \lstinline{businessLayer_graphics_create},
функция очищает дескриптор и возвращает адрес памяти дескриптора. Для инициализации используется функция \lstinline{businessLayer_graphics_open}, в который передаются дескриптор,
название слоя, адрес памяти для работы с изображением, а также размер памяти. Функция инициализации определяет начальное состояние иконок и элементов на экране используя
общие определения для всех подмодулей:

\begin{itemize}
    \item \lstinline{BUSINESSLAYER_GRAPHICS_ICON_HIDE} -- используется для скрытия иконок без динамического отображения;
    \item \lstinline{BUSINESSLAYER_GRAPHICS_ICON_SHOW} -- используется для отображения иконок без динамического отображения;
    \item \lstinline{BUSINESSLAYER_GRAPHICS_INT_HIDE} -- используется для скрытия модулей использующих целые числа для представления информации;
    \item \lstinline{BUSINESSLAYER_GRAPHICS_INT_SHOW_INVALID_VALUE} -- используется для обработки неверных данных переданный в модуль графики, ожидающего целые числа на вход, обычно значение скрывается -- пользователь замечает ошибку;
    \item \lstinline{BUSINESSLAYER_GRAPHICS_DOUBLE_HIDE} -- используется для скрытия модулей использующих числа с плавающей точкой для представления информации;
    \item \lstinline{BUSINESSLAYER_GRAPHICS_DOUBLE_SHOW_INVALID_VALUE} -- используется для обработки неверных данных переданный в модуль графики, ожидающего числа с плавающей точкой на вход, обычно значение скрывается -- пользователь замечает ошибку;
    \item \lstinline{BUSINESSLAYER_GRAPHICS_DOUBLE_SHOW} -- используется для отображения начального состояния в модуле графики, ожидающего числа с плавающей точкой на вход.
\end{itemize}

Все иконки храняться в двумерном массиве представляющем из себя последовательность из 4 каналов: RGBA, структура данных хранящее массив изображения и его длину имеет название \lstinline{businessLayer_graphics_font_t}.

Далее инициализирует все элементы перечислением \lstinline{*_HIDE}, тем самым задавая начальное состояние для каждого элемента на экране.
После этого запускается поток с дескриптором \lstinline{redrawStateScreenPt}. В дескрипторе хранятся координаты всех типов сущностей изображений для взаимодеиствия потока
с функциями установки значений.

Для данного дипломного проекта в рамках его темы будет рассмотрена реализация отображения используя данные из модуля \moduleOrientationAzimuth, и модуля \moduleFindTarget .

\subsubsection{Отображение азимута}

Для отображения азимута потребуется реализовать шкалу, значения и иконку компаса. Иконка компаса может принимать значения \lstinline{ICON_HIDE} и \lstinline{ICON_SHOW}.
Так как иконка не подразумевает динамическое перемещения, для нее задаются фиксированные координаты определенные в структуре \lstinline{businessLayer_graphics_redrawPicture_t}, в которой есть следующие поля:

\begin{itemize}
    \item \lstinline{positionOnScreen.x} -- положение на экране по-горизонтали;
    \item \lstinline{positionOnScreen.y} -- положение на экране по-вертикали;
    \item \lstinline{backgroundColor} -- цвет фона.
\end{itemize}

Чтобы отобразить или скрыть иконку требуется вызов функции \lstinline{businessLayer_graphics_determineCompass}, при получении значения \lstinline{ICON_HIDE} иконка и шкала компаса
будет скрыта, при значении \lstinline{ICON_SHOW} иконка появится вместе со шкалой и при другом значении лежащем в пределах от 0 до 360 будет отрисовываться азимут.
После определения состояния компаса оно будет обработано в потоке модуля графики, где используя функцию \lstinline{businessLayer_graphicsHelpful_fill} в память будет записана заранее сгенерированная иконка компаса.

Для отображения значения азимута требуется отобразить целое число градусов текущего азимута, символы, также как и иконки, представляют заранее сгенерированные иконки. Положение
значения компаса определено в структуре \lstinline{businessLayer_graphicsHelpful_stringParams_t} и имеет следующие атрибуты:

\begin{itemize}
    \item \lstinline{positionOnScreen.x} -- положение на экране по-горизонтали;
    \item \lstinline{positionOnScreen.y} -- положение на экране по-вертикали;
    \item \lstinline{fontSize} -- размер шрифта;
    \item \lstinline{backgroundColor} -- цвет фона;
    \item \lstinline{horizontalAlignment} -- тип выравнивания по горизонтали.
\end{itemize}

В случае, когда требуется скрыть иконку делается вызов \lstinline{businessLayer_graphics_determineAzimuth} со значением \lstinline{ICON_HIDE},
и в значение строки записывается символ "-", означающий отсутствие какой либо информации. Далее поток обрабатывает записанную в строку информацию, отображая ее
при помощи функции \lstinline{businessLayer_graphicsHelpful_printString}, данная функция принимает структуру с параметрами строки, а также принимает координаты
в которые будут записаны значения координат согласно размеру строки. Так как размер шрифта неравномерный в зависимости от символа, предусмотрено стирание области,
где были записаны предыдущие символы функцией \lstinline{businessLayer_graphicsHelpful_fill}. После успешной записи в память изображения, данные в кэш памяти
отмечаются как невалидные функцией \lstinline{businessLayer_invalidateDataCache}.

Идея отображения шкалы компаса в динамике состоит в том, чтобы перемещать заранее сгенерированную шкалу относительно фиксированной рамки. В статической области памяти
шкала имеет вид линейки со значениями от 0 до 360. Можно было бы использовать шкалу с размером ограничивающей рамки, однако это накладывает определенные ограничения относительно
динамического отображения. Первое из них -- это требуется обрабатывать случаи перекрытия текущего и предыдущего изображения с целью скрытия лишних элементов, второе --
требуется продумать алгоритм, который будет представлять массив в виде кольца и перемещать это кольцо внутри рамки, обрабатывая случаи отображения головы и хвоста массива.
Идея описанная выше накладывает алгоритмические сложности: увеличивает количество условных переходов при перерисовке, которые нужно предусмотреть, а также необходимо за несколько
раз отрисовывать изображение. Иной подход увеличивает количество занимаемой памяти, однако уменьшает сложность отрисовки до минимума где необходимо вычислить только координаты
области изображения которые нужно отрисовать. В первом описанном случае требовалось совершить минимум три вызова \lstinline{businessLayer_graphicsHelpful_fill}, для
того чтобы отрисовать иконку и скрыть лишнее. Во втором требуется только один вызов функции, в которой будет отрисована необходимая область шкалы.

Шкала компаса записана в структуру, особенность которой в том, что она хранит размер рамки в которую будет вписано изображение:

\begin{itemize}
    \item \lstinline{positionOnScreen.x} -- положение на экране по-горизонтали;
    \item \lstinline{positionOnScreen.y} -- положение на экране по-вертикали;
    \item \lstinline{pictureWindowSize.x} -- длина рамки по горизонтали;
    \item \lstinline{pictureWindowSize.y} -- длина рамки по вертикали;
    \item \lstinline{backgroundColor} -- цвет фона.
\end{itemize}

Отображение шкалы начинается с функции определения значения и состояния шкалы и иконки компаса, в которой обрабатываются случаи скрытия и отображения иконки, при получении целого числа
от 0 до 360, функция вызывает \lstinline{businessLayer_determineLocationCompassScaleHorizontal} и вычисляет значение координат шкалы, которые будут записаны в память для отрисовки.
Поток отрисовки ожидает изменения координат по горизонтали, при изменении происходит вызов \lstinline{businessLayer_graphicsHelpful_printPartIcon}, которая отрисовывает только указанную
область массива, а также в конце вызовет \lstinline{businessLayer_invalidateDataCache}, для того чтобы избежать появления случайных элементов на экране в процессе перерисовки.

\subsubsection{Отображение ориентации прибора в пространстве}

Отображение прибора в пространстве заключается в отображении его наклона по оси X и по оси Y, через данные которые передаются от модуля \moduleOrientationAzimuth.
Для отображения наклона по горизонтали и вертикали используются две шкалы, для левой и правой стороны экрана соответственно. Принцип отрисовки боковых шкал такой же как
и в отрисовке шкалы компаса. В случае, когда шкалы наклона работают, иконка соответствующего режима работает. 

Иконка наклона также хранит данные о положении иконки и ее цвете фона в структуре \lstinline{businessLayer_graphics_redrawPicture_t}, функция \lstinline{businessLayer_graphics_determineHorizon}
обрабатывает устанавливаемые состояния, это могут быть \lstinline{ICON_HIDE} и \lstinline{ICON_SHOW} для скрытия и установки иконки компаса соответственно, 
так и целые значения от -90 до 90 градусов.

В потоке обрабатываются все установленные состояния, для иконки вызывается функция \lstinline{businessLayer_graphicsHelpful_fill}, в которую передается
изображении иконки наклона, а также через функции \lstinline{businessLayer_graphics_detDeviationRight} и \lstinline{businessLayer_graphics_detDeviationLeft} определяется координата иконки
для правой и левой шкалы наклона соответственно и изменяет их в соответствии со значением. Если координаты по вертикали были изменены, то поток отображения перерисует данную шкалу
используя функцию \lstinline{businessLayer_graphicsHelpful_printPartIcon} и после всего этого конце вызовет \lstinline{businessLayer_invalidateDataCache},
для того чтобы избежать появления случайных элементов на экране в процессе перерисовки.

\subsubsection{Отображение позиции цели}

Отображение позиции цели на экране состоит в том чтобы в соответствии с текущим азимутом и азимутом цели указать на ту область в экране где расположена цель.

Для отображения позиции на экране определены следующие состояния которые приходят на модуль через функцию \lstinline{businessLayer_graphics_detFindTarget}:

\begin{itemize}
    \item \lstinline{BUSINESSLAYER_GRAPHICS_DOUBLE_HIDE} -- скрывает иконку стрелки пока не придет значение \lstinline{BUSINESSLAYER_GRAPHICS_DOUBLE_SHOW};
    \item \lstinline{BUSINESSLAYER_GRAPHICS_DOUBLE_SHOW} -- показывает иконку стрелки на ее изначальном положении;
    \item \lstinline{BUSINESSLAYER_GRAPHICS_DOUBLE_SHOW_INVALID_VALUE} -- скрывает иконку, но не останавливает обработку других приходящих значений, в случае если пришло правильное значение
    отображение возобновляется.
\end{itemize}

Предполагается три вида иконок информирующих пользователя о том где расположена цель и функция \lstinline{businessLayer_graphics_detFindTarget} в зависимости от значения устанавливает их
в дескриптор графики:

\begin{itemize}
    \item \lstinline{BUSINESSLAYER_GRAPHICS_FIND_TARGET_LEFT} -- определяет, что прибор нужно повернуть влево для того чтобы обнаружить цель;
    \item \lstinline{BUSINESSLAYER_GRAPHICS_FIND_TARGET_RIGHT} -- определяет, что прибор нужно повернуть вправо для того чтобы обнаружить цель; 
    \item \lstinline{BUSINESSLAYER_GRAPHICS_FIND_TARGET_CENTER} -- определяет, что цель цель находится в пределах экрана, поток отображения в данном случае буде использовать
    вычисленные координаты на экране.
\end{itemize}

Для динамического отображения центральной стрелки требуется переместить ее в соответствии с установленными координатами и далее скрыть ту область которая уже не нужна.
Поток обработки графики проверяет смещение по горизонтали и вертикали, и если перемещение было то стирает изображение или часть изображения используя функцию
\lstinline{businessLayer_graphics_eraseFindTarget}, эта функция проверяет како тип стрелки бы перемещен, как перекрывается текущая и предыдущая стрелка и стирает
ту область памяти где нет перекрытия предыдущей иконки. 

После отрисовки память хранящая предыдущую и текущую иконку инвалидируется, чтобы избежать появления неверных данных на изображении при динамической перерисовке. 

\subsubsection{Отображение определения движения}

Работа данной части модуля графики состоит в том чтобы обрабатывать входящие значения от модуля \moduleMoveDetect и устанавливать \lstinline{ICON_HIDE} и \lstinline{ICON_SHOW}
в зависимости от того есть движение или нет, при ситуации когда движение есть, поток модуля графики отрисовывает красную метку координаты которой определены в \lstinline{businessLayer_graphics_redrawPicture_t}.
Иначе поток скрывает метку, и ожидает пока не поступит состояние на отрисовку, в случае движения прибора. 

Также при движении происходит обращение драйверу видеопотока,
который включает режим картинка-в-картинке, в случае остановки прибора после движения, при возобновлении движения модуль скрывает иконку и режим картинка-в-картинке.

\subsection{Mодуль \moduleFlashMemory}

Модуль обеспечивает работу с флэш памятью для того чтобы хранить, записывать и читать параметры и прошивки. Модуль также позволяет работать через UART, USB и специальное 
ПО, которое работает по такому же протоколу как модуль UART. Защита данных модуля заключается в блокировке чтения и записи определенных регионов памяти, можно сказать что это
не самый надежный способ, однако один из самых простых. 

\subsubsection{Драйвер флэш памяти}

Драйвер взаимодействует с поддерживаемыми типами флэш памяти. Драйвер вынесен на уровень абстракции бизнес логики потому что, поддерживаемые FPGA типы памяти имеют
одинаковые команды и интерфейс общения, а значит модуль фактически можно считать платформо-независимым. Модуль обеспечивает основные функции флэш памяти: запись и чтение,
а также настройку работы флэш памяти. 

За работу модуля отвечают несколько потоков:

\begin{itemize}
    \item \lstinline{readThread} -- поток чтения;
    \item \lstinline{readStatusRegisterThread} -- поток чтения статуса памяти;
    \item \lstinline{enableWriteThread} -- поток разрешения операции записи;
    \item \lstinline{eraseSectorThread} -- поток очистки сектора;
    \item \lstinline{writeThread} -- поток записи;
    \item \lstinline{baseThread} -- поток обработки асинхронных запросов к модулю. 
\end{itemize}

Определены следующие внутренние состояния модуля, которые контролируется потоками:

\begin{itemize}
    \item \lstinline{FLASH_HIGH_LEVEL_OPERATION_NONE} -- модуль не выполняет никаких операций;
    \item \lstinline{FLASH_HIGH_LEVEL_OPERATION_READ} -- модуль выполняет операцию чтения;
    \item \lstinline{FLASH_HIGH_LEVEL_OPERATION_ERASE} -- модуль выполняет операцию очистки сектора;
    \item \lstinline{FLASH_HIGH_LEVEL_OPERATION_WRITE} -- модуль выполняет операцию записи;
\end{itemize}

Для создания дескриптора используется функция \lstinline{businessLayer_flash_create},
функция очищает дескриптор и возвращает адрес памяти дескриптора. Для инициализации используется функция \lstinline{businessLayer_flash_open},
в который передаются, созданный ранее дескриптор, дескриптор SPI, и выбором микросхемы на линии SPI. В функции открытия происходит запуск основного потока
обработки запросов: \lstinline{baseThread} и устанавливается состояние \lstinline{FLASH_HIGH_LEVEL_OPERATION_NONE}.

Из функций доступного API можно выделить функции чтения, записи и очистки сектора.
Для чтения данных из флэш памяти используется функция \lstinline{businessLayer_flashReadAsync}, которая принимает дескриптор флэш памяти, адрес для чтения, указатель на данные,
куда будут помещены прочитанные данные, длину данных.
Так как функция асинхронная, то она принимает еще обратный вызов и аргумент обратного вызова. Функция устанавливает состояние потока в \lstinline{FLASH_HIGH_LEVEL_OPERATION_READ}.
Для очистки сектора используется функция \lstinline|businessLayer_flashEraseSectorAsync|, которая принимает дескриптор, адрес и функцию обратного вызова с ее аргументом. Функция
устанавливает состояние потока как \lstinline{FLASH_HIGH_LEVEL_OPERATION_ERASE}.
Для записи используется функция \lstinline|businessLayer_flashWriteAsync|,которая принимает дескриптор флэш памяти, адрес для записи, указатель на данные, которые будут записаны,
длину данных. Так как функция асинхронная, то она принимает еще обратный вызов и аргумент обратного вызова. Функция устанавливает состояние потока как  \lstinline{FLASH_HIGH_LEVEL_OPERATION_WRITE}.

% TODO: для объема можно описывать и другие функции помимо  основных
Основной поток \lstinline|businessLayer_flashThread| обрабатывает асинхронные запросы и установленные состояния, и в соответствии с этим вызывает определенные дочерние потоки
В случе если пришла обработка запроса на чтение, то будет вызван поток \lstinline|readThread|, который принимает дескриптор флэш памяти, дескриптор потока и указатель на
данные куда они будут записаны после считывания.
В случае обработки потока на запись будет вызван дочерний поток \lstinline|writeThread|, который принимает дескриптор флэш памяти, дескриптор потока и указатель на
данные для записи во флэш память.
В случае обработки потока на очистку сектора будет вызван дочерний поток \lstinline|eraseThread|, который принимает дескриптор флэш памяти, дескриптор потока.

Чтобы остановить обработку команд и соответственно поток обработки, следует вызвать функцию \lstinline|businessLayer_flashClose|.

\nomenclaturex{SPI}{.}{.}

\subsubsection{Модуль взаимодейтсвия флэш памяти и UART}

Данный модуль отвечает за выполнение команд от модуля UART, и производит взаимодействие пользователя с флэш памятью прибора, позволяя ему читать и записывать данные
посредством UART-USB. Основная функция данного модуля -- организация записи прошивки во флэш память, с целью обновления прибора. Чтение же можно использовать для
вычитывания параметров отвечающих за функционал всего прибора.  Также данный модуль защищает данные от вычитывания или записи, если это предусмотрено. 

Модуль не имеет потоков, а всего лишь реализует общение с драйвером флэш памяти для организации чтения и записи данных. 

% Для того чтобы записать данные используется последовательный метод, то есть все состояния обрабатываются друг за другом. Это медленный способ записи
% однако у данного способа есть одно преимущество на данной стадии программного продукта: гарантируется правильная запись данных в случае ошибок, и прибор может
% быть запущен если на какой-то стадии (кроме стадии записи во флэш память) случились проблемы, то есть такой метод хоть и медленный, но гарантирует надежность.
% В случае же с конвейерной обработкой данных на запись усложнится механизм контроля за целостностью и последовательностью. 
% Если какой либо этап конвейера провалится, конвейер требуется перезапустить, если случиться критическая ошибка, то вероятно в память будут записаны не все данные.
% Данный метод можно назвать ненадежным. 

Для записи модулю требуется пройти через определенное количество состояний: 

\begin{itemize}
    \item \lstinline|MODULE_STATUS_OPENED| -- состояние говорит о том, что модуль готов для обработки запроса записи данных.
    \item \lstinline|MODULE_STATUS_FLASHING_START| -- модуль принял команду для записи;
    \item \lstinline|MODULE_STATUS_START_WRITING_IN_RAM| -- модуль записывает принимаемые пакеты в оперативную память;
    \item \lstinline|MODULE_STATUS_STOP_WRITING_IN_RAM| -- модуль закончил записывать принимаемые пакеты в оперативную память;
    \item \lstinline|MODULE_STATUS_START_WRITING_TO_FLASH| -- модуль записывает принимаемые пакеты в флеш память;
    \item \lstinline|MODULE_STATUS_STOP_WRITING_TO_FLASH| -- модуль закончил записывать принимаемые пакеты в флеш память;
\end{itemize}

Чтение происходит за одну операцию.

Для того чтобы создать дескриптор модуля необходимо вызвать функцию \lstinline|businessLayer_flashingTool_create|. Для инициализации модуля
необходимо вызвать функцию \lstinline|businessLayer_flashingTool_open|, который принимает дескриптор модуля, и регионы, которые определены для
записи и чтения.

Если пришел запрос на запись, то в первую очередь вызовется функция \lstinline|businessLayer_flashingTool_startFlashingOperation|, 
