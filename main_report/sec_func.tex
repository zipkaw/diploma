\section{ФУНКЦИОНАЛЬНОЕ ПРОЕКТИРОВАНИЕ}
\label{sec:func}

В данном разделе модули описаны с точки зрения разработки функций, которые реализуются в
дипломном проекте. Функциональное проектирование нацелено на создание корректно и
эффективно работающего проекта. Представление необходимого функционала~-- основная задача
текущего раздела. После анализа требуемых для реализации программного продукта
функций, было решено разбить программу на следующие модули:

\begin{itemize}
    \item модуль \modulePerifery;
    \item модуль \moduleCalib;
    \item модуль \moduleCalibControl;
    \item модуль \moduleUart;
    \item модуль \moduleMoveDetect;
    \item модуль \moduleOrientationAzimuth;
    \item модуль \moduleFindTarget;
    \item модуль \moduleFlashMemory;
    \item модуль \moduleGraphics.
\end{itemize}

Каждый из модулей что был описан в предыдущем разделе, будет рассмотрен более детально
в данном разделе. Для реализации каждого модуля требуется реализация определенных функций
позволяющих соответствовать модулю заявленным требованиям.
Каждая функция называется определенным способом: сначала идет название модуля в котором располагается,
далее название разделяется символом <<\_>> и описывается то что делает данная функция.

Так как ПО работает без операционной системы на микроконтроллере, взаимодействие между модулями происходит
внутри одной программы и следовательно память используется общая, поэтому важно обеспечить изолированные
области памяти для каждого модуля, для корректной работы всей программы. Делается это через закрытый интерфейс,
а наружу выдается лишь адрес дескриптора с которым работает модуль. Также из-за отсутствия ОС необходимо,
реализовать потоки и переключение контекста в системе: делается это при помощи библиотеки <<ProtoThreads>>.
Данная библиотека предоставляет единицу программной обработки, обеспечиваемая средствами языка Cи, и позволяет
не задействовать механизмы потоков операционной системы.

Каждый модуль имеет собственные сообщения ошибок, которые позволяют модулям определять их состояние на выходе функции.
Ошибки начинаются с префикса, обозначающего названия модуля, и заканчивается описанием ошибки. Все модули включают в себя следующие
ошибки (<<*>> отмечено название модуля):

\begin{itemize}
    \item \lstinline{*_OK}~-- код успешного завершения функции;
    \item \lstinline{*_ERROR_UNKNOWN}~-- код в случае, если ошибка не установлена, например, 
    такой код возврата может быть, в случае неопределенного поведения как исполняемого модуля, так и внешнего;
    \item \lstinline{*_ERROR_INVALID_ARGUMENT}~-- код, если был подан неверный аргумент в функцию;
\end{itemize}

Остальные ошибки зависящие от реализации конкретного модуля определены в его открытом API, и содержат подробное описание ошибки.

Далее будет описана реализация каждого модуля, которая состоит из инициализации его дескриптора, функций обеспечивающих логику работы модуля
и потоков реализующих работу модуля.

Алгоритм получения и обработки данных представлен на схеме
данных \dataScheme. 
%% TODO: Add sequence diagram

\subsection{Описание работы библиотеки <<ProtoThreads>>}
%% Todo: узнать про причины использования РТ
При разработке программного обеспечения в связи с ограниченными ресурсами микроконтроллера было выбрана <<bare-metal>>
разработка~-- это означает, что программа исполняется на уровне процессора, обходя слой операционной системы.
В связи с отсутствием операционной системы работа приложения может быть очень долгой из-за синхронной обработки модулем событий:
во время работы модуля, различные ожидания могут очень сильно останавливать работу других модулей и, следовательно работу всего устройства в целом.
Из-за долгих ожиданий могут теряться важные сообщения из внешнего мира и периферии.

Переход на асинхронный режим позволяет решить проблему ожиданий во время работы модуля, вводит такое понятие как переключение контекста~-- переход программы
от одной задачи к другой, при этом данные в первой задаче сохраняются и ждут очереди на обработку, пока контекст снова не переключится на них. Также асинхронный
режим работы модуля позволяет делать асинхронные вызовы функций, их суть заключается в том, что в такие функции передается запрос на чтение/запись/обработку данных
и в параметры передается функция обратного вызова. Внутри асинхронных функций устанавливаются нужные флаги, и когда модуль, чей асинхронный вызов был использован,
обработает запрос, он вызовет переданную функцию обратного вызова с необходимыми данными. Модуль который обращался к асинхронной функции обработает данные переданные в обратный вызов
во время работы своего потока. Таким образом обеспечивается работа модулей только тогда, когда наступит их время выполнения, после одной итерации процесса происходит переключения контекста.

Для работы <<ProtoThreads>> необходимо знать только номер строки в модуле, где произошло переключение контекста, номер строки хранится в структуре
с которой работают примитивы библиотеки. В дипломном проектировании используются следующие примитивы библиотеки:

\begin{itemize}
    \item \lstinline{PT_INIT}~-- инициализирует поток;
    \item \lstinline{PT_BEGIN}~-- объявляет начало потока, данный примитив выполняет возобновление контекста(т.е. переход в то место процесса, где было совершено переключение контекста);
    \item \lstinline{PT_END}~-- объявляет завершение потока;
    \item \lstinline{PT_WAIT_UNTIL}~-- выполняет остановку потока, и ждет, когда условие не станет истинно, в ином случае переключает контекст.
    \item \lstinline{PT_WAIT_WHILE}~-- выполняет остановку потока, и ждет, когда условие истинно, в ином случае переключает контекст.
    \item \lstinline{PT_RESTART}~-- выполняет сброс потока и переключает контекст.
    \item \lstinline{PT_YIELD}~-- выполняет переключение контекста, поток продолжит работу начиная место вызова этого примитива.
    \item \lstinline{PT_SPAWN}~-- выполняет запуск дочернего потока и ожидает его завершения.
\end{itemize}

В ходе работы появилась необходимость, в расширении возможностей потоков, с целью улучшения читаемости кода,
поэтому на основе описанных выше примитивов были созданы новые функции управлением потоками:

\begin{itemize}
    \item \lstinline{PT_SLEEP_*}~-- переводит поток в ожидание на определенное время,
    вместо <<*>> может быть указано MS либо SEC, что означает, что указанное время передано в миллисекундах или секундах соответственно.
    После истечения времени поток возобновляет работу в месте где произошло переключение контекста;
    \item \lstinline{PT_WAIT_UNTIL_WITH_TIMEOUT_*}~-- ожидает выполнения пока условия с таймаутом пока оно не станет истинно
    по истечении которого выводится сообщение об истечении времени, вместо <<*>> может быть указано MS либо SEC,
    что означает, что указанное время передано в миллисекундах или секундах соответственно;
    \item \lstinline{PT_WAIT_WHILE_WITH_TIMEOUT_*}~-- ожидает выполнения пока условия с таймаутом пока оно истинно
    по истечении которого выводится сообщение об истечении времени, вместо <<*>> может быть указано MS либо SEC,
    что означает, что указанное время передано в миллисекундах или секундах соответственно;
    \item \lstinline{PT_WAIT_INFINITE}~-- переключает поток в зацикленный режим, необходим для того чтобы процесс был гарантированно остановлен и не мог начать работу заново.
    \item \lstinline{PT_PARENT_SANITY_CHECK_ALWAYS_N}~-- выполняет проверку истинности условия в родительском потоке,
    в случае ложного условия перезапустит поток и выведет сообщение об ошибке.
    \item \lstinline{PT_CHILD_SANITY_CHECK_ALWAYS_N}~-- выполняет проверку истинности условия в дочернем потоке,
    в случае ложного условия перезапустит поток и выведет сообщение об ошибке.
\end{itemize}

\nomenclaturex{SoC}{.}{.}

\subsection{Модуль \modulePerifery}

Модуль \modulePerifery\ является одной из частей блока приема и обработки
датчиков. Модуль внутри содержит драйвера для двух датчиков: магнитометра, акселерометра и гироскопа(2-в-1).

\subsubsection{Драйвер магнитометра}

Библиотека с реализацией драйвера магнитометра использует функции, перечисления и структуры,
которые начинаются с префикса \lstinline{magnetoMMC5633NJL_}. Для создания дескриптора модуля используется функция
\lstinline{magnetoMMC5633NJL_create}, данная функция не принимает никаких аргументов, внутри, данная функция, сначала проверяет
был ли создан уже дескриптор, если был то функция возвращает невалидный дескриптор обозначающий ошибку его создания, в ином случае
функция обнуляет данные в памяти дескриптора и возвращает его адрес. Чтобы запустить модуль необходимо его открыть при помощи функции
\lstinline{magnetoMMC5633NJL_open}. В функцию открытия модуля передаются параметры необходимые для работы модуля, первый из этих параметров
~-- это адрес дескриптора модуля, следующий параметр это дескриптор драйвера шины IIC, необходимый для конфигурации датчика и чтения оттуда данных, и последние два параметра
это функция обратного вызова и аргумент передаваемый в эту функцию.
