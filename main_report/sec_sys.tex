\section{СИСТЕМНОЕ ПРОЕКТИРОВАНИЕ}
\label{sec:sys}

В данном разделе описано разбиение проекта на модули. Это производится для того, чтобы программный продукт был переносимым на различные платформы (с операционными системами и без). 
Данный программный продукт может работать как без операционной системы (bare-metal), а также на следующих операционных системах: 
\begin{itemize}
    \item Linux;
    \item FreeRTOS;
    \item TI-RTOS.
\end{itemize}

Разработка программного продукта по модулям позволяет разрабатывать его в команде, а также улучшает его функциональное и интеграционное тестирование: 
каждый модуль выполняет свой заложенный функционал с минимальными зависимостями.
Также модули позволяют грамотно разделить программный продукт на платформо-зависимые и кроссплатформенные части. 

После анализа требуемых для реализации программного продукта функций было решено разбить программу на следующие модули:

\begin{itemize}
    \item модуль \modulePerifery;
    \item модуль \moduleCalib;
    \item модуль \moduleCalibControl;
    \item модуль \moduleUart;
    \item модуль \moduleMoveDetect;
    \item модуль \moduleOrientationAzimuth;
    \item модуль \moduleFindTarget;
    \item модуль \moduleFlashMemory;
    \item модуль \moduleGraphics.
\end{itemize}

Взаимосвязь между основными компонентами проекта отражена на структурной схеме
\structScheme.

\subsection{Модуль \modulePerifery}

Модуль \modulePerifery является платформо-зависимым модулем и обеспечивает взаимодействие с датчиками
(магнетометр, акселерометр, гироскоп) посредством IIC шины. Данный модуль обеспечивает начальную конфигурацию 
модулей, выполняет проверку работоспособности посредством вычитывания идентификатора датчика и проведения 
операции самотестирования. Модуль по готовности данных от датчиков выполняет их отправку в модуль \moduleCalib~.

\subsection{Модуль \moduleCalib}

Данный модуль является одним из важных модулей, который калибрует входящие данные от модуля \modulePerifery, и передает их дальше
в модули \moduleMoveDetect~, \moduleOrientationAzimuth~. Важность объясняется тем что данный модуль 
находится на границе платформо-зависимой части (модуль \modulePerifery~ и модуль \moduleFlashMemory) и платформо-независимой (все остальные модули) и 
без данного модуля бизнес логика связанная и инерциальными датчиками работать не будет из-за невалидных данных.

Помимо калибровки входных данных модуль реализует расчет калибровочных матриц. Начало процесса калибровки датчиков инициирует модуль \moduleCalibControl~,
который позволяет выбирать какой из датчиков необходимо откалибровать, и позволяет прервать процесс калибровки в любой момент. Расчет калибровочных 
параметров начинается со сборки данных от модуля \modulePerifery~ и заканчивается расчетами и сохранением параметров через модуль \moduleFlashMemory.
После расчета калибровочных параметров модуль возобновляет свою работу и отдает данные для модуля \moduleOrientationAzimuth~, \moduleMoveDetect
уже с обновленными калибровочными параметрами, без необходимости перезагрузки или повторной инициализации. 

При запуске прибора и инициализации модулей, модуль \moduleCalib запрашивает сохраненные данные из модуля \moduleFlashMemory~.
Предусмотрен случай вычитки из флэш памяти неверных параметров, такое может случиться из-за наводок на SPI-шину или если данные во флэш-памяти
оказались испорчены, а также если во флэш памяти ничего не оказалось записано.
Проверка целостности калибровочных матриц обеспечивается СRC32 кодом,
данный код вычисляется после расчета калибровочной матрицы и перед записью ее во флэш-память, а во время чтения из флэш-памяти, прочитанный
CRC32 код, сравнивается с кодом, вычисленным в ходе выполнения программы.
В случае несовпадения кодов модуль читает из памяти программы
стандартную калибровочную матрицу, которая никак не меняет входные данные. В случае успешной вычитки матрицы она записывается в память программы.

\nomenclaturex{CRC32}{.}{.}


\subsection{Модуль \moduleCalibControl}

Задачей данного модуля является обеспечить контроль процесса калибровки следуя командам, которые модуль получает
через модуль \moduleUart~. Команда содержит в себе такую полезную информацию как целевой калибруемый модуль и состояние 
в которое привел пользователь устройство, например, повернул его в необходимое положение. Также помимо приема команд 
модуль отправляет в ответ команду с сообщением об успешности того или иного шага калибровки устройства.

Взаимодействие с модулем \moduleCalib через его API c вызовом соответствующих функций калибровок. Хоть и оба модуля относятся к калибровке,
их разделение на несколько модулей было сделано с целью выделения ведущего и ведомого модуля. Ведущим модулем тут выступает модуль \moduleCalibControl~, 
ведомым ~-- \moduleCalib~. Целью ведущего модуля является контроль соответствия, отправляемых команд модулем \moduleUart~, с состоянием конечного 
автомата модуля \moduleCalib. 

\nomenclaturex{API}{.}{.}

\subsection{Модуль \moduleUart}

Работа модуля в устройстве заключается в приеме команд от других микроконтроллеров и процессоров. В данном дипломном проекте
этот модуль рассматривается как звено между внешним пользователем и модулем \moduleCalib~. Но данный модуль также может принимать
и другие команды и делать соответствующие вызовы. 

Прием команд по UART от пользователя состоит из нескольких частей. Начинается прием из обработки прерывания контроллера UART из 
FIFO очереди которого забираются данные. Далее принятые данные кладутся во внутренний кольцевой буфер, и начинается ожидание обработки
потоком чтения модуля. После того как данные в потоке чтения будут прочитаны происходит этап валидации команд. 
Проверка команд производится с помощью заранее определенного протокола команд, состоящего из соответствия названия команды и номера, 
а также длины полезной нагрузки. После проверки соответствия модуль переходит к этапу выполнения команды, на данном этапе он может вызвать
выполнять соответствующую команду, если он не находит реализацию команды, то модуль вернет ошибку, иначе, согласно протоколу отправит ответ.

Также, помимо приема, модуль может отправлять команды. Нужно это как для отправки собственных команд, так и для пересылки их другим устройствам.
Процесс отправки начинается с заполнения кольцевого буфера командой, далее команда в буфере ждет очереди отправки через поток записи. В ответ на отправку
команды модуль ждет ответной команды для подтверждения успешной пересылки.

\nomenclaturex{UART}{Universal asynchronus receive transmit}{.}
\nomenclaturex{FIFO}{.}{.}

\subsection{Модуль \moduleMoveDetect}

Модуль используется для определения вращательного перемещения прибора в различных плоскостях. Корнем данного модуля является
БИХ фильтр, который отфильтровывает резкие вращательные движения и вращения с более высокой угловой скоростью.
Модуль получает откалиброванные данные от модуля \moduleCalib~ и помещает вектор измерений по трем осям в БИХ фильтр
и далее определяет превысила ли порог угловая скорость хотя бы на одной из осей, если произошло то модуль отправляет событие 
в модуль \moduleGraphics~ в котором происходит последующая обработка данного события на уровне близкому к взаимодействию с пользователем.

Выбор в сторону БИХ фильтра вместо обработки данных модуля \moduleOrientationAzimuth~ был выбран потому что реализация 
с БИХ фильтром давала более лучшую отзывчивость и скорость обработки движений при различных нестандартных событиях.
Например, после тряски устройства отзывчивость модуля \moduleMoveDetect~ была более быстрая, чем если бы модуль обрабатывал
данные из модуля \moduleOrientationAzimuth~. 

Особенностью модуля является то что при старте ему требуется некоторое количество итераций. Связанно это с БИХ фильтром, из-за наличия
обратных связей фильтр в начале работы может неверно реагировать на действия пользователя и соответственно давать неверный результат.

\subsection{Модуль \moduleOrientationAzimuth}

Рассматриваемый модуль условно модуль можно разделить на два подмодуля, первый из них рассчитывает положения прибора в пространстве,
а второй определяет азимут прибора. Первый подмодуль аккумулирует в себе данные от всех датчиков получая их от \moduleCalib~, 
далее подмодуль отфильтровывает данные используя фильтр Мэджвика (рассмотрен в ) и возвращает готовую позицию прибора в пространстве.
Второй подмодуль принимает только данные от магнетометра из модуля \moduleCalib, данные от GPS и данные о позиции прибора в пространстве
от первого подмодуля.
После приема всех данных второй подмодуль рассчитывает азимут и выполняет поправку на наклон прибора в 
пространстве и добавляет к азимуту текущее магнитное наклонение.

В ходе работы модуль отслеживает чтобы данные от каждого устройства из модуля \moduleCalib били измерены в один промежуток времени. Если это не так
модуль инвалидирует данные и ожидает приема новых данных. Если принятые данные валидные модуль делает соответствующие вызовы из
модуля \moduleGraphics~, и отображает данные о наклоне прибора по-горизонтали и вертикали для пользователя, а также отображает текущий азимут.
Также модуль \moduleOrientationAzimuth взаимодействует с модулем \moduleFindTarget~, для которого он возвращает текущий азимут.

Было решено не делить на данный модуль на два модуля: модуль расчета ориентации и модуль расчета азимута, потому что оба модуля используют данные от модуля
\moduleCalib~, и отправляют данные в модуль \moduleGraphics~. Также увеличение сущностей привело бы к росту программного кода, что может быть критическим местом
на микроконтроллере.

\subsection{Модуль \moduleFindTarget}

Модуль взаимодействует с модулем \moduleOrientationAzimuth и использует азимут прибора для определения азимута цели. 
На вход данного модуля поступает азимут и далее модуль находит положение цели на экране с учетом
текущего поля зрения и цифрового увеличения прибора. Информацию о найденной цели на экране модуль отправляет в модуль \moduleGraphics~ 
в которой происходит отрисовка изображения.

\subsection{Модуль \moduleFlashMemory}

Данный модуль имеет важное значение в готовом продукте: модуль \moduleFlashMemory выполняет запись во флэш-память настроек прибора,
прошивки прибора и калибровочных параметров. В данном дипломном проектировании модуль \moduleFlashMemory рассматривается как звено
обеспечивающее хранение калибровочных параметров. Поэтому на схеме описана связь модуля \moduleFlashMemory и модуля \moduleCalib.
Помимо чтения и записи из программы модуль может делать это используя UART при помощи модуля \moduleUart~.
По команде описанной в протоколе, происходит запрос на вычитку или запись данных из флэш памяти.
После получения команды по UART происходит несколько этапов, первый из них это проверка на то можно ли читать/записывать данные из запрашиваемого адреса,
для калибровочных параметров чтение разрешено, для прошивок ~-- нет. Далее, в случае чтения, данные вычитываются из флеш-памяти и проверяется их CRC32
код и в случае совпадения кодов данные помещаются в RAM память, иначе происходит вторая попытка чтения, и в случае неуспеха модуль отправляет обратно в 
модуль \moduleUart код с ошибкой. После данные из RAM памяти передается в модуль \moduleUart~, где они дальше передаются по UART. Запись происходит несколько наоборот:
приходит команда на запись и модуль \moduleFlashMemory готов принимать данные в RAM с расчетом CRC кода. После данные передаются по UART в RAM и в конце передачи модуль переходит в состояние
записи во флэш-память. После записи во флэш-память происходит очистка раннее записанных данных в RAM.

Модуль платформо-зависимый, хотя интерфейс общения между микроконтроллером и другими 
флэш-памятями очень похож. Недостатками данного модуля можно выделить отсутствие потокового чтения/записи.

\nomenclaturex{RAM}{.}{.}

\subsection{Модуль \moduleGraphics}

Модуль графики обеспечивает взаимодействие с пользователем посредством отображения информации на экране.
Модуль взаимодействует с такими модулями как \moduleOrientationAzimuth и \moduleFindTarget~, и для каждого из модулей
предусмотрена своя машина состояний реализующая динамическое отображение. Данный модуль работает с двумерным массивом
содержащим изображения и записывает данные в DMA блок микроконтроллера. Далее в аппаратной части происходит считывание из DMA 
и формирование видеопотока на дисплей. Обработка приходящих событий и отрисовка информации происходит в потоке.

\nomenclaturex{DMA}{.}{.}

% TODO: add gps module nd describe bearing in domain
